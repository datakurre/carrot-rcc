"use strict";(self.webpackChunk_JUPYTERLAB_CORE_OUTPUT=self.webpackChunk_JUPYTERLAB_CORE_OUTPUT||[]).push([[1753],{65246:(t,n,e)=>{e.d(n,{I:()=>s});var r=e(40959),a=e(75138);class s{constructor(t){this._history=[],this._executionCount=0,this._isDisposed=!1,this._disposed=new a.Signal(this),this._parentHeader=void 0,this._parent=void 0;const{id:n,name:e,sendMessage:r}=t;this._id=n,this._name=e,this._sendMessage=r}get ready(){return Promise.resolve()}get isDisposed(){return this._isDisposed}get disposed(){return this._disposed}get id(){return this._id}get name(){return this._name}get executionCount(){return this._executionCount}get parentHeader(){return this._parentHeader}get parent(){return this._parent}dispose(){this.isDisposed||(this._isDisposed=!0,this._disposed.emit(void 0))}async handleMessage(t){switch(this._busy(t),this._parent=t,t.header.msg_type){case"kernel_info_request":await this._kernelInfo(t);break;case"execute_request":await this._execute(t);break;case"input_reply":this.inputReply(t.content);break;case"inspect_request":await this._inspect(t);break;case"is_complete_request":await this._isCompleteRequest(t);break;case"complete_request":await this._complete(t);break;case"history_request":await this._historyRequest(t);break;case"comm_open":await this.commOpen(t);break;case"comm_msg":await this.commMsg(t);break;case"comm_close":await this.commClose(t)}this._idle(t)}stream(t,n){var e;const a=void 0!==n?n:this._parentHeader,s=r.KernelMessage.createMessage({channel:"iopub",msgType:"stream",session:null!==(e=null==a?void 0:a.session)&&void 0!==e?e:"",parentHeader:a,content:t});this._sendMessage(s)}displayData(t,n){var e,a;const s=void 0!==n?n:this._parentHeader;t.metadata=null!==(e=t.metadata)&&void 0!==e?e:{};const i=r.KernelMessage.createMessage({channel:"iopub",msgType:"display_data",session:null!==(a=null==s?void 0:s.session)&&void 0!==a?a:"",parentHeader:s,content:t});this._sendMessage(i)}inputRequest(t,n){var e;const a=void 0!==n?n:this._parentHeader,s=r.KernelMessage.createMessage({channel:"stdin",msgType:"input_request",session:null!==(e=null==a?void 0:a.session)&&void 0!==e?e:"",parentHeader:a,content:t});this._sendMessage(s)}publishExecuteResult(t,n){var e;const a=void 0!==n?n:this._parentHeader,s=r.KernelMessage.createMessage({channel:"iopub",msgType:"execute_result",session:null!==(e=null==a?void 0:a.session)&&void 0!==e?e:"",parentHeader:a,content:t});this._sendMessage(s)}publishExecuteError(t,n){var e;const a=void 0!==n?n:this._parentHeader,s=r.KernelMessage.createMessage({channel:"iopub",msgType:"error",session:null!==(e=null==a?void 0:a.session)&&void 0!==e?e:"",parentHeader:a,content:t});this._sendMessage(s)}updateDisplayData(t,n){var e;const a=void 0!==n?n:this._parentHeader,s=r.KernelMessage.createMessage({channel:"iopub",msgType:"update_display_data",session:null!==(e=null==a?void 0:a.session)&&void 0!==e?e:"",parentHeader:a,content:t});this._sendMessage(s)}clearOutput(t,n){var e;const a=void 0!==n?n:this._parentHeader,s=r.KernelMessage.createMessage({channel:"iopub",msgType:"clear_output",session:null!==(e=null==a?void 0:a.session)&&void 0!==e?e:"",parentHeader:a,content:t});this._sendMessage(s)}handleComm(t,n,e,a,s){var i;const o=void 0!==s?s:this._parentHeader,p=r.KernelMessage.createMessage({channel:"iopub",msgType:t,session:null!==(i=null==o?void 0:o.session)&&void 0!==i?i:"",parentHeader:o,content:n,metadata:e,buffers:a});this._sendMessage(p)}_idle(t){const n=r.KernelMessage.createMessage({msgType:"status",session:t.header.session,parentHeader:t.header,channel:"iopub",content:{execution_state:"idle"}});this._sendMessage(n)}_busy(t){const n=r.KernelMessage.createMessage({msgType:"status",session:t.header.session,parentHeader:t.header,channel:"iopub",content:{execution_state:"busy"}});this._sendMessage(n)}async _kernelInfo(t){const n=await this.kernelInfoRequest(),e=r.KernelMessage.createMessage({msgType:"kernel_info_reply",channel:"shell",session:t.header.session,parentHeader:t.header,content:n});this._sendMessage(e)}async _historyRequest(t){const n=t,e=r.KernelMessage.createMessage({msgType:"history_reply",channel:"shell",parentHeader:n.header,session:t.header.session,content:{status:"ok",history:this._history}});this._sendMessage(e)}_executeInput(t){const n=t,e=n.content.code,a=r.KernelMessage.createMessage({msgType:"execute_input",parentHeader:n.header,channel:"iopub",session:t.header.session,content:{code:e,execution_count:this._executionCount}});this._sendMessage(a)}async _execute(t){const n=t,e=n.content;this._executionCount++,this._parentHeader=n.header,this._executeInput(n),this._history.push([0,0,e.code]);const a=await this.executeRequest(n.content),s=r.KernelMessage.createMessage({msgType:"execute_reply",channel:"shell",parentHeader:n.header,session:t.header.session,content:a});this._sendMessage(s)}async _complete(t){const n=t,e=await this.completeRequest(n.content),a=r.KernelMessage.createMessage({msgType:"complete_reply",parentHeader:n.header,channel:"shell",session:t.header.session,content:e});this._sendMessage(a)}async _inspect(t){const n=t,e=await this.inspectRequest(n.content),a=r.KernelMessage.createMessage({msgType:"inspect_reply",parentHeader:n.header,channel:"shell",session:t.header.session,content:e});this._sendMessage(a)}async _isCompleteRequest(t){const n=t,e=await this.isCompleteRequest(n.content),a=r.KernelMessage.createMessage({msgType:"is_complete_reply",parentHeader:n.header,channel:"shell",session:t.header.session,content:e});this._sendMessage(a)}}},64831:(t,n,e)=>{e.d(n,{L:()=>a,q:()=>s});var r=e(9727);const a=new r.Token("@jupyterlite/kernel:IKernels"),s=new r.Token("@jupyterlite/kernelspec:IKernelSpecs")},51753:(t,n,e)=>{e.r(n),e.d(n,{default:()=>y});var r=e(14390),a=e(64831),s=e(65246),i=e(9727),o=e(52111),p=e(35696),l=e(74496),m=e(53514),u=e(28084),c=e(11686);class d extends s.I{constructor(t){var n;super(t),this._executeDelegate=new i.PromiseDelegate,this._ready=new i.PromiseDelegate;const{pyodideUrl:e}=t,a=m,s=r.URLExt.join(window.location.origin,a),d=u,y=r.URLExt.join(window.location.origin,d),f=c,g=r.URLExt.join(window.location.origin,f),h=null!==(n=t.pyoliteWheel)&&void 0!==n?n:l,x=r.URLExt.join(window.location.origin,h),v=localStorage.getItem("env")||"{}",b=e.slice(0,e.lastIndexOf("/")+1),w=new Blob([[`importScripts("${e}");`,p,`var indexURL = "${b}";`,`var _widgetsnbextensionWheelUrl = '${s}';`,`var _nbformatWheelUrl = '${y}';`,`var _ipykernelWheelUrl = '${g}';`,`var _pyoliteWheelUrl = '${x}';`,`var _envJson = '${v.replace(/'/g,"\\''")}';`,o].join("\n")]);this._worker=new Worker(window.URL.createObjectURL(w)),this._worker.onmessage=t=>{this._processWorkerMessage(t.data)},this._ready.resolve()}dispose(){this.isDisposed||(console.log(`Dispose worker for kernel ${this.id}`),this._worker.terminate(),super.dispose())}get ready(){return this._ready.promise}_processWorkerMessage(t){var n,e,r,a,s,i,o;switch(t.type){case"stream":{const e=null!==(n=t.bundle)&&void 0!==n?n:{name:"stdout",text:""};this.stream(e,t.parentHeader);break}case"input_request":{const n=null!==(e=t.content)&&void 0!==e?e:{prompt:"",password:!1};this.inputRequest(n,t.parentHeader);break}case"reply":{const n=t.results;this._executeDelegate.resolve(n);break}case"display_data":{const n=null!==(r=t.bundle)&&void 0!==r?r:{data:{},metadata:{},transient:{}};this.displayData(n,t.parentHeader);break}case"update_display_data":{const n=null!==(a=t.bundle)&&void 0!==a?a:{data:{},metadata:{},transient:{}};this.updateDisplayData(n,t.parentHeader);break}case"clear_output":{const n=null!==(s=t.bundle)&&void 0!==s?s:{wait:!1};this.clearOutput(n,t.parentHeader);break}case"execute_result":{const n=null!==(i=t.bundle)&&void 0!==i?i:{execution_count:0,data:{},metadata:{}};this.publishExecuteResult(n,t.parentHeader);break}case"execute_error":{const n=null!==(o=t.bundle)&&void 0!==o?o:{ename:"",evalue:"",traceback:[]};this.publishExecuteError(n,t.parentHeader);break}case"comm_msg":case"comm_open":case"comm_close":this.handleComm(t.type,t.content,t.metadata,t.buffers,t.parentHeader);break;default:this._executeDelegate.resolve({data:{},metadata:{}})}}async kernelInfoRequest(){return{implementation:"pyodide",implementation_version:"0.1.0",language_info:{codemirror_mode:{name:"python",version:3},file_extension:".py",mimetype:"text/x-python",name:"python",nbconvert_exporter:"python",pygments_lexer:"ipython3",version:"3.8"},protocol_version:"5.3",status:"ok",banner:"Pyolite: A WebAssembly-powered Python kernel backed by Pyodide",help_links:[{text:"Python (WASM) Kernel",url:"https://pyodide.org"}]}}async executeRequest(t){const n=await this._sendRequestMessageToWorker("execute-request",t);return{execution_count:this.executionCount,...n}}async completeRequest(t){return await this._sendRequestMessageToWorker("complete-request",t)}async inspectRequest(t){return await this._sendRequestMessageToWorker("inspect-request",t)}async isCompleteRequest(t){return await this._sendRequestMessageToWorker("is-complete-request",t)}async commInfoRequest(t){return await this._sendRequestMessageToWorker("comm-info-request",t)}inputReply(t){this._worker.postMessage({type:"input-reply",data:t,parent:this.parent})}async commOpen(t){return await this._sendRequestMessageToWorker("comm-open",t)}async commMsg(t){return await this._sendRequestMessageToWorker("comm-msg",t)}async commClose(t){return await this._sendRequestMessageToWorker("comm-close",t)}async _sendRequestMessageToWorker(t,n){return this._executeDelegate=new i.PromiseDelegate,this._worker.postMessage({type:t,data:n,parent:this.parent}),await this._executeDelegate.promise}}const y=[{id:"@jupyterlite/pyolite-kernel-extension:kernel",autoStart:!0,requires:[a.q],activate:(t,n)=>{const e=r.PageConfig.getOption("pyodideUrl")||"https://cdn.jsdelivr.net/pyodide/v0.18.1/full/pyodide.js",a=r.URLExt.isLocal(e)?r.URLExt.join(window.location.origin,e):e;n.register({spec:{name:"python",display_name:"Pyolite",language:"python",argv:[],spec:{argv:[],env:{},display_name:"Pyolite",language:"python",interrupt_mode:"message",metadata:{}},resources:{"logo-32x32":"TODO","logo-64x64":"/kernelspecs/python.png"}},create:async t=>new d({...t,pyodideUrl:a})})}}]},11686:(t,n,e)=>{t.exports=e.p+"ipykernel-5.5.5-py3-none-any.whl"},28084:(t,n,e)=>{t.exports=e.p+"nbformat-4.2.0-py3-none-any.whl"},74496:(t,n,e)=>{t.exports=e.p+"pyolite-0.1.0a6-py3-none-any.whl"},53514:(t,n,e)=>{t.exports=e.p+"widgetsnbextension-3.5.0-py3-none-any.whl"},35696:t=>{t.exports='(function (global, factory) {\n  typeof exports === \'object\' && typeof module !== \'undefined\' ? module.exports = factory() :\n  typeof define === \'function\' && define.amd ? define(factory) :\n  (global = typeof globalThis !== \'undefined\' ? globalThis : global || self, global.BpmnModdle = factory());\n}(this, (function () { \'use strict\';\n\n  /**\n   * Flatten array, one level deep.\n   *\n   * @param {Array<?>} arr\n   *\n   * @return {Array<?>}\n   */\n\n  var nativeToString = Object.prototype.toString;\n  var nativeHasOwnProperty = Object.prototype.hasOwnProperty;\n  function isUndefined(obj) {\n    return obj === undefined;\n  }\n  function isArray(obj) {\n    return nativeToString.call(obj) === \'[object Array]\';\n  }\n  function isObject(obj) {\n    return nativeToString.call(obj) === \'[object Object]\';\n  }\n  function isFunction(obj) {\n    var tag = nativeToString.call(obj);\n    return tag === \'[object Function]\' || tag === \'[object AsyncFunction]\' || tag === \'[object GeneratorFunction]\' || tag === \'[object AsyncGeneratorFunction]\' || tag === \'[object Proxy]\';\n  }\n  function isString(obj) {\n    return nativeToString.call(obj) === \'[object String]\';\n  }\n  /**\n   * Return true, if target owns a property with the given key.\n   *\n   * @param {Object} target\n   * @param {String} key\n   *\n   * @return {Boolean}\n   */\n\n  function has(target, key) {\n    return nativeHasOwnProperty.call(target, key);\n  }\n\n  /**\n   * Find element in collection.\n   *\n   * @param  {Array|Object} collection\n   * @param  {Function|Object} matcher\n   *\n   * @return {Object}\n   */\n\n  function find(collection, matcher) {\n    matcher = toMatcher(matcher);\n    var match;\n    forEach(collection, function (val, key) {\n      if (matcher(val, key)) {\n        match = val;\n        return false;\n      }\n    });\n    return match;\n  }\n  /**\n   * Find element in collection.\n   *\n   * @param  {Array|Object} collection\n   * @param  {Function} matcher\n   *\n   * @return {Array} result\n   */\n\n  function filter(collection, matcher) {\n    var result = [];\n    forEach(collection, function (val, key) {\n      if (matcher(val, key)) {\n        result.push(val);\n      }\n    });\n    return result;\n  }\n  /**\n   * Iterate over collection; returning something\n   * (non-undefined) will stop iteration.\n   *\n   * @param  {Array|Object} collection\n   * @param  {Function} iterator\n   *\n   * @return {Object} return result that stopped the iteration\n   */\n\n  function forEach(collection, iterator) {\n    var val, result;\n\n    if (isUndefined(collection)) {\n      return;\n    }\n\n    var convertKey = isArray(collection) ? toNum : identity;\n\n    for (var key in collection) {\n      if (has(collection, key)) {\n        val = collection[key];\n        result = iterator(val, convertKey(key));\n\n        if (result === false) {\n          return val;\n        }\n      }\n    }\n  }\n\n  function toMatcher(matcher) {\n    return isFunction(matcher) ? matcher : function (e) {\n      return e === matcher;\n    };\n  }\n\n  function identity(arg) {\n    return arg;\n  }\n\n  function toNum(arg) {\n    return Number(arg);\n  }\n  /**\n   * Bind function against target <this>.\n   *\n   * @param  {Function} fn\n   * @param  {Object}   target\n   *\n   * @return {Function} bound function\n   */\n\n  function bind(fn, target) {\n    return fn.bind(target);\n  }\n\n  function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n\n      return target;\n    };\n\n    return _extends.apply(this, arguments);\n  }\n\n  /**\n   * Convenience wrapper for `Object.assign`.\n   *\n   * @param {Object} target\n   * @param {...Object} others\n   *\n   * @return {Object} the target\n   */\n\n  function assign(target) {\n    for (var _len = arguments.length, others = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      others[_key - 1] = arguments[_key];\n    }\n\n    return _extends.apply(void 0, [target].concat(others));\n  }\n  /**\n   * Pick given properties from the target object.\n   *\n   * @param {Object} target\n   * @param {Array} properties\n   *\n   * @return {Object} target\n   */\n\n  function pick(target, properties) {\n    var result = {};\n    var obj = Object(target);\n    forEach(properties, function (prop) {\n      if (prop in obj) {\n        result[prop] = target[prop];\n      }\n    });\n    return result;\n  }\n\n  /**\n   * Moddle base element.\n   */\n  function Base() { }\n\n  Base.prototype.get = function(name) {\n    return this.$model.properties.get(this, name);\n  };\n\n  Base.prototype.set = function(name, value) {\n    this.$model.properties.set(this, name, value);\n  };\n\n  /**\n   * A model element factory.\n   *\n   * @param {Moddle} model\n   * @param {Properties} properties\n   */\n  function Factory(model, properties) {\n    this.model = model;\n    this.properties = properties;\n  }\n\n\n  Factory.prototype.createType = function(descriptor) {\n\n    var model = this.model;\n\n    var props = this.properties,\n        prototype = Object.create(Base.prototype);\n\n    // initialize default values\n    forEach(descriptor.properties, function(p) {\n      if (!p.isMany && p.default !== undefined) {\n        prototype[p.name] = p.default;\n      }\n    });\n\n    props.defineModel(prototype, model);\n    props.defineDescriptor(prototype, descriptor);\n\n    var name = descriptor.ns.name;\n\n    /**\n     * The new type constructor\n     */\n    function ModdleElement(attrs) {\n      props.define(this, \'$type\', { value: name, enumerable: true });\n      props.define(this, \'$attrs\', { value: {} });\n      props.define(this, \'$parent\', { writable: true });\n\n      forEach(attrs, bind(function(val, key) {\n        this.set(key, val);\n      }, this));\n    }\n\n    ModdleElement.prototype = prototype;\n\n    ModdleElement.hasType = prototype.$instanceOf = this.model.hasType;\n\n    // static links\n    props.defineModel(ModdleElement, model);\n    props.defineDescriptor(ModdleElement, descriptor);\n\n    return ModdleElement;\n  };\n\n  /**\n   * Built-in moddle types\n   */\n  var BUILTINS = {\n    String: true,\n    Boolean: true,\n    Integer: true,\n    Real: true,\n    Element: true\n  };\n\n  /**\n   * Converters for built in types from string representations\n   */\n  var TYPE_CONVERTERS = {\n    String: function(s) { return s; },\n    Boolean: function(s) { return s === \'true\'; },\n    Integer: function(s) { return parseInt(s, 10); },\n    Real: function(s) { return parseFloat(s); }\n  };\n\n  /**\n   * Convert a type to its real representation\n   */\n  function coerceType(type, value) {\n\n    var converter = TYPE_CONVERTERS[type];\n\n    if (converter) {\n      return converter(value);\n    } else {\n      return value;\n    }\n  }\n\n  /**\n   * Return whether the given type is built-in\n   */\n  function isBuiltIn(type) {\n    return !!BUILTINS[type];\n  }\n\n  /**\n   * Return whether the given type is simple\n   */\n  function isSimple(type) {\n    return !!TYPE_CONVERTERS[type];\n  }\n\n  /**\n   * Parses a namespaced attribute name of the form (ns:)localName to an object,\n   * given a default prefix to assume in case no explicit namespace is given.\n   *\n   * @param {String} name\n   * @param {String} [defaultPrefix] the default prefix to take, if none is present.\n   *\n   * @return {Object} the parsed name\n   */\n  function parseName(name, defaultPrefix) {\n    var parts = name.split(/:/),\n        localName, prefix;\n\n    // no prefix (i.e. only local name)\n    if (parts.length === 1) {\n      localName = name;\n      prefix = defaultPrefix;\n    } else\n    // prefix + local name\n    if (parts.length === 2) {\n      localName = parts[1];\n      prefix = parts[0];\n    } else {\n      throw new Error(\'expected <prefix:localName> or <localName>, got \' + name);\n    }\n\n    name = (prefix ? prefix + \':\' : \'\') + localName;\n\n    return {\n      name: name,\n      prefix: prefix,\n      localName: localName\n    };\n  }\n\n  /**\n   * A utility to build element descriptors.\n   */\n  function DescriptorBuilder(nameNs) {\n    this.ns = nameNs;\n    this.name = nameNs.name;\n    this.allTypes = [];\n    this.allTypesByName = {};\n    this.properties = [];\n    this.propertiesByName = {};\n  }\n\n\n  DescriptorBuilder.prototype.build = function() {\n    return pick(this, [\n      \'ns\',\n      \'name\',\n      \'allTypes\',\n      \'allTypesByName\',\n      \'properties\',\n      \'propertiesByName\',\n      \'bodyProperty\',\n      \'idProperty\'\n    ]);\n  };\n\n  /**\n   * Add property at given index.\n   *\n   * @param {Object} p\n   * @param {Number} [idx]\n   * @param {Boolean} [validate=true]\n   */\n  DescriptorBuilder.prototype.addProperty = function(p, idx, validate) {\n\n    if (typeof idx === \'boolean\') {\n      validate = idx;\n      idx = undefined;\n    }\n\n    this.addNamedProperty(p, validate !== false);\n\n    var properties = this.properties;\n\n    if (idx !== undefined) {\n      properties.splice(idx, 0, p);\n    } else {\n      properties.push(p);\n    }\n  };\n\n\n  DescriptorBuilder.prototype.replaceProperty = function(oldProperty, newProperty, replace) {\n    var oldNameNs = oldProperty.ns;\n\n    var props = this.properties,\n        propertiesByName = this.propertiesByName,\n        rename = oldProperty.name !== newProperty.name;\n\n    if (oldProperty.isId) {\n      if (!newProperty.isId) {\n        throw new Error(\n          \'property <\' + newProperty.ns.name + \'> must be id property \' +\n          \'to refine <\' + oldProperty.ns.name + \'>\');\n      }\n\n      this.setIdProperty(newProperty, false);\n    }\n\n    if (oldProperty.isBody) {\n\n      if (!newProperty.isBody) {\n        throw new Error(\n          \'property <\' + newProperty.ns.name + \'> must be body property \' +\n          \'to refine <\' + oldProperty.ns.name + \'>\');\n      }\n\n      // TODO: Check compatibility\n      this.setBodyProperty(newProperty, false);\n    }\n\n    // validate existence and get location of old property\n    var idx = props.indexOf(oldProperty);\n    if (idx === -1) {\n      throw new Error(\'property <\' + oldNameNs.name + \'> not found in property list\');\n    }\n\n    // remove old property\n    props.splice(idx, 1);\n\n    // replacing the named property is intentional\n    //\n    //  * validate only if this is a "rename" operation\n    //  * add at specific index unless we "replace"\n    //\n    this.addProperty(newProperty, replace ? undefined : idx, rename);\n\n    // make new property available under old name\n    propertiesByName[oldNameNs.name] = propertiesByName[oldNameNs.localName] = newProperty;\n  };\n\n\n  DescriptorBuilder.prototype.redefineProperty = function(p, targetPropertyName, replace) {\n\n    var nsPrefix = p.ns.prefix;\n    var parts = targetPropertyName.split(\'#\');\n\n    var name = parseName(parts[0], nsPrefix);\n    var attrName = parseName(parts[1], name.prefix).name;\n\n    var redefinedProperty = this.propertiesByName[attrName];\n    if (!redefinedProperty) {\n      throw new Error(\'refined property <\' + attrName + \'> not found\');\n    } else {\n      this.replaceProperty(redefinedProperty, p, replace);\n    }\n\n    delete p.redefines;\n  };\n\n  DescriptorBuilder.prototype.addNamedProperty = function(p, validate) {\n    var ns = p.ns,\n        propsByName = this.propertiesByName;\n\n    if (validate) {\n      this.assertNotDefined(p, ns.name);\n      this.assertNotDefined(p, ns.localName);\n    }\n\n    propsByName[ns.name] = propsByName[ns.localName] = p;\n  };\n\n  DescriptorBuilder.prototype.removeNamedProperty = function(p) {\n    var ns = p.ns,\n        propsByName = this.propertiesByName;\n\n    delete propsByName[ns.name];\n    delete propsByName[ns.localName];\n  };\n\n  DescriptorBuilder.prototype.setBodyProperty = function(p, validate) {\n\n    if (validate && this.bodyProperty) {\n      throw new Error(\n        \'body property defined multiple times \' +\n        \'(<\' + this.bodyProperty.ns.name + \'>, <\' + p.ns.name + \'>)\');\n    }\n\n    this.bodyProperty = p;\n  };\n\n  DescriptorBuilder.prototype.setIdProperty = function(p, validate) {\n\n    if (validate && this.idProperty) {\n      throw new Error(\n        \'id property defined multiple times \' +\n        \'(<\' + this.idProperty.ns.name + \'>, <\' + p.ns.name + \'>)\');\n    }\n\n    this.idProperty = p;\n  };\n\n  DescriptorBuilder.prototype.assertNotDefined = function(p, name) {\n    var propertyName = p.name,\n        definedProperty = this.propertiesByName[propertyName];\n\n    if (definedProperty) {\n      throw new Error(\n        \'property <\' + propertyName + \'> already defined; \' +\n        \'override of <\' + definedProperty.definedBy.ns.name + \'#\' + definedProperty.ns.name + \'> by \' +\n        \'<\' + p.definedBy.ns.name + \'#\' + p.ns.name + \'> not allowed without redefines\');\n    }\n  };\n\n  DescriptorBuilder.prototype.hasProperty = function(name) {\n    return this.propertiesByName[name];\n  };\n\n  DescriptorBuilder.prototype.addTrait = function(t, inherited) {\n\n    var typesByName = this.allTypesByName,\n        types = this.allTypes;\n\n    var typeName = t.name;\n\n    if (typeName in typesByName) {\n      return;\n    }\n\n    forEach(t.properties, bind(function(p) {\n\n      // clone property to allow extensions\n      p = assign({}, p, {\n        name: p.ns.localName,\n        inherited: inherited\n      });\n\n      Object.defineProperty(p, \'definedBy\', {\n        value: t\n      });\n\n      var replaces = p.replaces,\n          redefines = p.redefines;\n\n      // add replace/redefine support\n      if (replaces || redefines) {\n        this.redefineProperty(p, replaces || redefines, replaces);\n      } else {\n        if (p.isBody) {\n          this.setBodyProperty(p);\n        }\n        if (p.isId) {\n          this.setIdProperty(p);\n        }\n        this.addProperty(p);\n      }\n    }, this));\n\n    types.push(t);\n    typesByName[typeName] = t;\n  };\n\n  /**\n   * A registry of Moddle packages.\n   *\n   * @param {Array<Package>} packages\n   * @param {Properties} properties\n   */\n  function Registry(packages, properties) {\n    this.packageMap = {};\n    this.typeMap = {};\n\n    this.packages = [];\n\n    this.properties = properties;\n\n    forEach(packages, bind(this.registerPackage, this));\n  }\n\n\n  Registry.prototype.getPackage = function(uriOrPrefix) {\n    return this.packageMap[uriOrPrefix];\n  };\n\n  Registry.prototype.getPackages = function() {\n    return this.packages;\n  };\n\n\n  Registry.prototype.registerPackage = function(pkg) {\n\n    // copy package\n    pkg = assign({}, pkg);\n\n    var pkgMap = this.packageMap;\n\n    ensureAvailable(pkgMap, pkg, \'prefix\');\n    ensureAvailable(pkgMap, pkg, \'uri\');\n\n    // register types\n    forEach(pkg.types, bind(function(descriptor) {\n      this.registerType(descriptor, pkg);\n    }, this));\n\n    pkgMap[pkg.uri] = pkgMap[pkg.prefix] = pkg;\n    this.packages.push(pkg);\n  };\n\n\n  /**\n   * Register a type from a specific package with us\n   */\n  Registry.prototype.registerType = function(type, pkg) {\n\n    type = assign({}, type, {\n      superClass: (type.superClass || []).slice(),\n      extends: (type.extends || []).slice(),\n      properties: (type.properties || []).slice(),\n      meta: assign((type.meta || {}))\n    });\n\n    var ns = parseName(type.name, pkg.prefix),\n        name = ns.name,\n        propertiesByName = {};\n\n    // parse properties\n    forEach(type.properties, bind(function(p) {\n\n      // namespace property names\n      var propertyNs = parseName(p.name, ns.prefix),\n          propertyName = propertyNs.name;\n\n      // namespace property types\n      if (!isBuiltIn(p.type)) {\n        p.type = parseName(p.type, propertyNs.prefix).name;\n      }\n\n      assign(p, {\n        ns: propertyNs,\n        name: propertyName\n      });\n\n      propertiesByName[propertyName] = p;\n    }, this));\n\n    // update ns + name\n    assign(type, {\n      ns: ns,\n      name: name,\n      propertiesByName: propertiesByName\n    });\n\n    forEach(type.extends, bind(function(extendsName) {\n      var extended = this.typeMap[extendsName];\n\n      extended.traits = extended.traits || [];\n      extended.traits.push(name);\n    }, this));\n\n    // link to package\n    this.definePackage(type, pkg);\n\n    // register\n    this.typeMap[name] = type;\n  };\n\n\n  /**\n   * Traverse the type hierarchy from bottom to top,\n   * calling iterator with (type, inherited) for all elements in\n   * the inheritance chain.\n   *\n   * @param {Object} nsName\n   * @param {Function} iterator\n   * @param {Boolean} [trait=false]\n   */\n  Registry.prototype.mapTypes = function(nsName, iterator, trait) {\n\n    var type = isBuiltIn(nsName.name) ? { name: nsName.name } : this.typeMap[nsName.name];\n\n    var self = this;\n\n    /**\n     * Traverse the selected trait.\n     *\n     * @param {String} cls\n     */\n    function traverseTrait(cls) {\n      return traverseSuper(cls, true);\n    }\n\n    /**\n     * Traverse the selected super type or trait\n     *\n     * @param {String} cls\n     * @param {Boolean} [trait=false]\n     */\n    function traverseSuper(cls, trait) {\n      var parentNs = parseName(cls, isBuiltIn(cls) ? \'\' : nsName.prefix);\n      self.mapTypes(parentNs, iterator, trait);\n    }\n\n    if (!type) {\n      throw new Error(\'unknown type <\' + nsName.name + \'>\');\n    }\n\n    forEach(type.superClass, trait ? traverseTrait : traverseSuper);\n\n    // call iterator with (type, inherited=!trait)\n    iterator(type, !trait);\n\n    forEach(type.traits, traverseTrait);\n  };\n\n\n  /**\n   * Returns the effective descriptor for a type.\n   *\n   * @param  {String} type the namespaced name (ns:localName) of the type\n   *\n   * @return {Descriptor} the resulting effective descriptor\n   */\n  Registry.prototype.getEffectiveDescriptor = function(name) {\n\n    var nsName = parseName(name);\n\n    var builder = new DescriptorBuilder(nsName);\n\n    this.mapTypes(nsName, function(type, inherited) {\n      builder.addTrait(type, inherited);\n    });\n\n    var descriptor = builder.build();\n\n    // define package link\n    this.definePackage(descriptor, descriptor.allTypes[descriptor.allTypes.length - 1].$pkg);\n\n    return descriptor;\n  };\n\n\n  Registry.prototype.definePackage = function(target, pkg) {\n    this.properties.define(target, \'$pkg\', { value: pkg });\n  };\n\n\n\n  ///////// helpers ////////////////////////////\n\n  function ensureAvailable(packageMap, pkg, identifierKey) {\n\n    var value = pkg[identifierKey];\n\n    if (value in packageMap) {\n      throw new Error(\'package with \' + identifierKey + \' <\' + value + \'> already defined\');\n    }\n  }\n\n  /**\n   * A utility that gets and sets properties of model elements.\n   *\n   * @param {Model} model\n   */\n  function Properties(model) {\n    this.model = model;\n  }\n\n\n  /**\n   * Sets a named property on the target element.\n   * If the value is undefined, the property gets deleted.\n   *\n   * @param {Object} target\n   * @param {String} name\n   * @param {Object} value\n   */\n  Properties.prototype.set = function(target, name, value) {\n\n    var property = this.model.getPropertyDescriptor(target, name);\n\n    var propertyName = property && property.name;\n\n    if (isUndefined$1(value)) {\n      // unset the property, if the specified value is undefined;\n      // delete from $attrs (for extensions) or the target itself\n      if (property) {\n        delete target[propertyName];\n      } else {\n        delete target.$attrs[name];\n      }\n    } else {\n      // set the property, defining well defined properties on the fly\n      // or simply updating them in target.$attrs (for extensions)\n      if (property) {\n        if (propertyName in target) {\n          target[propertyName] = value;\n        } else {\n          defineProperty(target, property, value);\n        }\n      } else {\n        target.$attrs[name] = value;\n      }\n    }\n  };\n\n  /**\n   * Returns the named property of the given element\n   *\n   * @param  {Object} target\n   * @param  {String} name\n   *\n   * @return {Object}\n   */\n  Properties.prototype.get = function(target, name) {\n\n    var property = this.model.getPropertyDescriptor(target, name);\n\n    if (!property) {\n      return target.$attrs[name];\n    }\n\n    var propertyName = property.name;\n\n    // check if access to collection property and lazily initialize it\n    if (!target[propertyName] && property.isMany) {\n      defineProperty(target, property, []);\n    }\n\n    return target[propertyName];\n  };\n\n\n  /**\n   * Define a property on the target element\n   *\n   * @param  {Object} target\n   * @param  {String} name\n   * @param  {Object} options\n   */\n  Properties.prototype.define = function(target, name, options) {\n    Object.defineProperty(target, name, options);\n  };\n\n\n  /**\n   * Define the descriptor for an element\n   */\n  Properties.prototype.defineDescriptor = function(target, descriptor) {\n    this.define(target, \'$descriptor\', { value: descriptor });\n  };\n\n  /**\n   * Define the model for an element\n   */\n  Properties.prototype.defineModel = function(target, model) {\n    this.define(target, \'$model\', { value: model });\n  };\n\n\n  function isUndefined$1(val) {\n    return typeof val === \'undefined\';\n  }\n\n  function defineProperty(target, property, value) {\n    Object.defineProperty(target, property.name, {\n      enumerable: !property.isReference,\n      writable: true,\n      value: value,\n      configurable: true\n    });\n  }\n\n  //// Moddle implementation /////////////////////////////////////////////////\n\n  /**\n   * @class Moddle\n   *\n   * A model that can be used to create elements of a specific type.\n   *\n   * @example\n   *\n   * var Moddle = require(\'moddle\');\n   *\n   * var pkg = {\n   *   name: \'mypackage\',\n   *   prefix: \'my\',\n   *   types: [\n   *     { name: \'Root\' }\n   *   ]\n   * };\n   *\n   * var moddle = new Moddle([pkg]);\n   *\n   * @param {Array<Package>} packages the packages to contain\n   */\n  function Moddle(packages) {\n\n    this.properties = new Properties(this);\n\n    this.factory = new Factory(this, this.properties);\n    this.registry = new Registry(packages, this.properties);\n\n    this.typeCache = {};\n  }\n\n\n  /**\n   * Create an instance of the specified type.\n   *\n   * @method Moddle#create\n   *\n   * @example\n   *\n   * var foo = moddle.create(\'my:Foo\');\n   * var bar = moddle.create(\'my:Bar\', { id: \'BAR_1\' });\n   *\n   * @param  {String|Object} descriptor the type descriptor or name know to the model\n   * @param  {Object} attrs   a number of attributes to initialize the model instance with\n   * @return {Object}         model instance\n   */\n  Moddle.prototype.create = function(descriptor, attrs) {\n    var Type = this.getType(descriptor);\n\n    if (!Type) {\n      throw new Error(\'unknown type <\' + descriptor + \'>\');\n    }\n\n    return new Type(attrs);\n  };\n\n\n  /**\n   * Returns the type representing a given descriptor\n   *\n   * @method Moddle#getType\n   *\n   * @example\n   *\n   * var Foo = moddle.getType(\'my:Foo\');\n   * var foo = new Foo({ \'id\' : \'FOO_1\' });\n   *\n   * @param  {String|Object} descriptor the type descriptor or name know to the model\n   * @return {Object}         the type representing the descriptor\n   */\n  Moddle.prototype.getType = function(descriptor) {\n\n    var cache = this.typeCache;\n\n    var name = isString(descriptor) ? descriptor : descriptor.ns.name;\n\n    var type = cache[name];\n\n    if (!type) {\n      descriptor = this.registry.getEffectiveDescriptor(name);\n      type = cache[name] = this.factory.createType(descriptor);\n    }\n\n    return type;\n  };\n\n\n  /**\n   * Creates an any-element type to be used within model instances.\n   *\n   * This can be used to create custom elements that lie outside the meta-model.\n   * The created element contains all the meta-data required to serialize it\n   * as part of meta-model elements.\n   *\n   * @method Moddle#createAny\n   *\n   * @example\n   *\n   * var foo = moddle.createAny(\'vendor:Foo\', \'http://vendor\', {\n   *   value: \'bar\'\n   * });\n   *\n   * var container = moddle.create(\'my:Container\', \'http://my\', {\n   *   any: [ foo ]\n   * });\n   *\n   * // go ahead and serialize the stuff\n   *\n   *\n   * @param  {String} name  the name of the element\n   * @param  {String} nsUri the namespace uri of the element\n   * @param  {Object} [properties] a map of properties to initialize the instance with\n   * @return {Object} the any type instance\n   */\n  Moddle.prototype.createAny = function(name, nsUri, properties) {\n\n    var nameNs = parseName(name);\n\n    var element = {\n      $type: name,\n      $instanceOf: function(type) {\n        return type === this.$type;\n      }\n    };\n\n    var descriptor = {\n      name: name,\n      isGeneric: true,\n      ns: {\n        prefix: nameNs.prefix,\n        localName: nameNs.localName,\n        uri: nsUri\n      }\n    };\n\n    this.properties.defineDescriptor(element, descriptor);\n    this.properties.defineModel(element, this);\n    this.properties.define(element, \'$parent\', { enumerable: false, writable: true });\n    this.properties.define(element, \'$instanceOf\', { enumerable: false, writable: true });\n\n    forEach(properties, function(a, key) {\n      if (isObject(a) && a.value !== undefined) {\n        element[a.name] = a.value;\n      } else {\n        element[key] = a;\n      }\n    });\n\n    return element;\n  };\n\n  /**\n   * Returns a registered package by uri or prefix\n   *\n   * @return {Object} the package\n   */\n  Moddle.prototype.getPackage = function(uriOrPrefix) {\n    return this.registry.getPackage(uriOrPrefix);\n  };\n\n  /**\n   * Returns a snapshot of all known packages\n   *\n   * @return {Object} the package\n   */\n  Moddle.prototype.getPackages = function() {\n    return this.registry.getPackages();\n  };\n\n  /**\n   * Returns the descriptor for an element\n   */\n  Moddle.prototype.getElementDescriptor = function(element) {\n    return element.$descriptor;\n  };\n\n  /**\n   * Returns true if the given descriptor or instance\n   * represents the given type.\n   *\n   * May be applied to this, if element is omitted.\n   */\n  Moddle.prototype.hasType = function(element, type) {\n    if (type === undefined) {\n      type = element;\n      element = this;\n    }\n\n    var descriptor = element.$model.getElementDescriptor(element);\n\n    return (type in descriptor.allTypesByName);\n  };\n\n  /**\n   * Returns the descriptor of an elements named property\n   */\n  Moddle.prototype.getPropertyDescriptor = function(element, property) {\n    return this.getElementDescriptor(element).propertiesByName[property];\n  };\n\n  /**\n   * Returns a mapped type\'s descriptor\n   */\n  Moddle.prototype.getTypeDescriptor = function(type) {\n    return this.registry.typeMap[type];\n  };\n\n  var fromCharCode = String.fromCharCode;\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  var ENTITY_PATTERN = /&#(\\d+);|&#x([0-9a-f]+);|&(\\w+);/ig;\n\n  var ENTITY_MAPPING = {\n    \'amp\': \'&\',\n    \'apos\': \'\\\'\',\n    \'gt\': \'>\',\n    \'lt\': \'<\',\n    \'quot\': \'"\'\n  };\n\n  // map UPPERCASE variants of supported special chars\n  Object.keys(ENTITY_MAPPING).forEach(function(k) {\n    ENTITY_MAPPING[k.toUpperCase()] = ENTITY_MAPPING[k];\n  });\n\n\n  function replaceEntities(_, d, x, z) {\n\n    // reserved names, i.e. &nbsp;\n    if (z) {\n      if (hasOwnProperty.call(ENTITY_MAPPING, z)) {\n        return ENTITY_MAPPING[z];\n      } else {\n\n        // fall back to original value\n        return \'&\' + z + \';\';\n      }\n    }\n\n    // decimal encoded char\n    if (d) {\n      return fromCharCode(d);\n    }\n\n    // hex encoded char\n    return fromCharCode(parseInt(x, 16));\n  }\n\n\n  /**\n   * A basic entity decoder that can decode a minimal\n   * sub-set of reserved names (&amp;) as well as\n   * hex (&#xaaf;) and decimal (&#1231;) encoded characters.\n   *\n   * @param {string} str\n   *\n   * @return {string} decoded string\n   */\n  function decodeEntities(s) {\n    if (s.length > 3 && s.indexOf(\'&\') !== -1) {\n      return s.replace(ENTITY_PATTERN, replaceEntities);\n    }\n\n    return s;\n  }\n\n  var XSI_URI = \'http://www.w3.org/2001/XMLSchema-instance\';\n  var XSI_PREFIX = \'xsi\';\n  var XSI_TYPE = \'xsi:type\';\n\n  var NON_WHITESPACE_OUTSIDE_ROOT_NODE = \'non-whitespace outside of root node\';\n\n  function error(msg) {\n    return new Error(msg);\n  }\n\n  function missingNamespaceForPrefix(prefix) {\n    return \'missing namespace for prefix <\' + prefix + \'>\';\n  }\n\n  function getter(getFn) {\n    return {\n      \'get\': getFn,\n      \'enumerable\': true\n    };\n  }\n\n  function cloneNsMatrix(nsMatrix) {\n    var clone = {}, key;\n    for (key in nsMatrix) {\n      clone[key] = nsMatrix[key];\n    }\n    return clone;\n  }\n\n  function uriPrefix(prefix) {\n    return prefix + \'$uri\';\n  }\n\n  function buildNsMatrix(nsUriToPrefix) {\n    var nsMatrix = {},\n        uri,\n        prefix;\n\n    for (uri in nsUriToPrefix) {\n      prefix = nsUriToPrefix[uri];\n      nsMatrix[prefix] = prefix;\n      nsMatrix[uriPrefix(prefix)] = uri;\n    }\n\n    return nsMatrix;\n  }\n\n  function noopGetContext() {\n    return { \'line\': 0, \'column\': 0 };\n  }\n\n  function throwFunc(err) {\n    throw err;\n  }\n\n  /**\n   * Creates a new parser with the given options.\n   *\n   * @constructor\n   *\n   * @param  {!Object<string, ?>=} options\n   */\n  function Parser(options) {\n\n    if (!this) {\n      return new Parser(options);\n    }\n\n    var proxy = options && options[\'proxy\'];\n\n    var onText,\n        onOpenTag,\n        onCloseTag,\n        onCDATA,\n        onError = throwFunc,\n        onWarning,\n        onComment,\n        onQuestion,\n        onAttention;\n\n    var getContext = noopGetContext;\n\n    /**\n     * Do we need to parse the current elements attributes for namespaces?\n     *\n     * @type {boolean}\n     */\n    var maybeNS = false;\n\n    /**\n     * Do we process namespaces at all?\n     *\n     * @type {boolean}\n     */\n    var isNamespace = false;\n\n    /**\n     * The caught error returned on parse end\n     *\n     * @type {Error}\n     */\n    var returnError = null;\n\n    /**\n     * Should we stop parsing?\n     *\n     * @type {boolean}\n     */\n    var parseStop = false;\n\n    /**\n     * A map of { uri: prefix } used by the parser.\n     *\n     * This map will ensure we can normalize prefixes during processing;\n     * for each uri, only one prefix will be exposed to the handlers.\n     *\n     * @type {!Object<string, string>}}\n     */\n    var nsUriToPrefix;\n\n    /**\n     * Handle parse error.\n     *\n     * @param  {string|Error} err\n     */\n    function handleError(err) {\n      if (!(err instanceof Error)) {\n        err = error(err);\n      }\n\n      returnError = err;\n\n      onError(err, getContext);\n    }\n\n    /**\n     * Handle parse error.\n     *\n     * @param  {string|Error} err\n     */\n    function handleWarning(err) {\n\n      if (!onWarning) {\n        return;\n      }\n\n      if (!(err instanceof Error)) {\n        err = error(err);\n      }\n\n      onWarning(err, getContext);\n    }\n\n    /**\n     * Register parse listener.\n     *\n     * @param  {string}   name\n     * @param  {Function} cb\n     *\n     * @return {Parser}\n     */\n    this[\'on\'] = function(name, cb) {\n\n      if (typeof cb !== \'function\') {\n        throw error(\'required args <name, cb>\');\n      }\n\n      switch (name) {\n      case \'openTag\': onOpenTag = cb; break;\n      case \'text\': onText = cb; break;\n      case \'closeTag\': onCloseTag = cb; break;\n      case \'error\': onError = cb; break;\n      case \'warn\': onWarning = cb; break;\n      case \'cdata\': onCDATA = cb; break;\n      case \'attention\': onAttention = cb; break; // <!XXXXX zzzz="eeee">\n      case \'question\': onQuestion = cb; break; // <? ....  ?>\n      case \'comment\': onComment = cb; break;\n      default:\n        throw error(\'unsupported event: \' + name);\n      }\n\n      return this;\n    };\n\n    /**\n     * Set the namespace to prefix mapping.\n     *\n     * @example\n     *\n     * parser.ns({\n     *   \'http://foo\': \'foo\',\n     *   \'http://bar\': \'bar\'\n     * });\n     *\n     * @param  {!Object<string, string>} nsMap\n     *\n     * @return {Parser}\n     */\n    this[\'ns\'] = function(nsMap) {\n\n      if (typeof nsMap === \'undefined\') {\n        nsMap = {};\n      }\n\n      if (typeof nsMap !== \'object\') {\n        throw error(\'required args <nsMap={}>\');\n      }\n\n      var _nsUriToPrefix = {}, k;\n\n      for (k in nsMap) {\n        _nsUriToPrefix[k] = nsMap[k];\n      }\n\n      // FORCE default mapping for schema instance\n      _nsUriToPrefix[XSI_URI] = XSI_PREFIX;\n\n      isNamespace = true;\n      nsUriToPrefix = _nsUriToPrefix;\n\n      return this;\n    };\n\n    /**\n     * Parse xml string.\n     *\n     * @param  {string} xml\n     *\n     * @return {Error} returnError, if not thrown\n     */\n    this[\'parse\'] = function(xml) {\n      if (typeof xml !== \'string\') {\n        throw error(\'required args <xml=string>\');\n      }\n\n      returnError = null;\n\n      parse(xml);\n\n      getContext = noopGetContext;\n      parseStop = false;\n\n      return returnError;\n    };\n\n    /**\n     * Stop parsing.\n     */\n    this[\'stop\'] = function() {\n      parseStop = true;\n    };\n\n    /**\n     * Parse string, invoking configured listeners on element.\n     *\n     * @param  {string} xml\n     */\n    function parse(xml) {\n      var nsMatrixStack = isNamespace ? [] : null,\n          nsMatrix = isNamespace ? buildNsMatrix(nsUriToPrefix) : null,\n          _nsMatrix,\n          nodeStack = [],\n          anonymousNsCount = 0,\n          tagStart = false,\n          tagEnd = false,\n          i = 0, j = 0,\n          x, y, q, w, v,\n          xmlns,\n          elementName,\n          _elementName,\n          elementProxy\n          ;\n\n      var attrsString = \'\',\n          attrsStart = 0,\n          cachedAttrs // false = parsed with errors, null = needs parsing\n          ;\n\n      /**\n       * Parse attributes on demand and returns the parsed attributes.\n       *\n       * Return semantics: (1) `false` on attribute parse error,\n       * (2) object hash on extracted attrs.\n       *\n       * @return {boolean|Object}\n       */\n      function getAttrs() {\n        if (cachedAttrs !== null) {\n          return cachedAttrs;\n        }\n\n        var nsUri,\n            nsUriPrefix,\n            nsName,\n            defaultAlias = isNamespace && nsMatrix[\'xmlns\'],\n            attrList = isNamespace && maybeNS ? [] : null,\n            i = attrsStart,\n            s = attrsString,\n            l = s.length,\n            hasNewMatrix,\n            newalias,\n            value,\n            alias,\n            name,\n            attrs = {},\n            seenAttrs = {},\n            skipAttr,\n            w,\n            j;\n\n        parseAttr:\n        for (; i < l; i++) {\n          skipAttr = false;\n          w = s.charCodeAt(i);\n\n          if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE={ \\f\\n\\r\\t\\v}\n            continue;\n          }\n\n          // wait for non whitespace character\n          if (w < 65 || w > 122 || (w > 90 && w < 97)) {\n            if (w !== 95 && w !== 58) { // char 95"_" 58":"\n              handleWarning(\'illegal first char attribute name\');\n              skipAttr = true;\n            }\n          }\n\n          // parse attribute name\n          for (j = i + 1; j < l; j++) {\n            w = s.charCodeAt(j);\n\n            if (\n              w > 96 && w < 123 ||\n              w > 64 && w < 91 ||\n              w > 47 && w < 59 ||\n              w === 46 || // \'.\'\n              w === 45 || // \'-\'\n              w === 95 // \'_\'\n            ) {\n              continue;\n            }\n\n            // unexpected whitespace\n            if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE\n              handleWarning(\'missing attribute value\');\n              i = j;\n\n              continue parseAttr;\n            }\n\n            // expected "="\n            if (w === 61) { // "=" == 61\n              break;\n            }\n\n            handleWarning(\'illegal attribute name char\');\n            skipAttr = true;\n          }\n\n          name = s.substring(i, j);\n\n          if (name === \'xmlns:xmlns\') {\n            handleWarning(\'illegal declaration of xmlns\');\n            skipAttr = true;\n          }\n\n          w = s.charCodeAt(j + 1);\n\n          if (w === 34) { // \'"\'\n            j = s.indexOf(\'"\', i = j + 2);\n\n            if (j === -1) {\n              j = s.indexOf(\'\\\'\', i);\n\n              if (j !== -1) {\n                handleWarning(\'attribute value quote missmatch\');\n                skipAttr = true;\n              }\n            }\n\n          } else if (w === 39) { // "\'"\n            j = s.indexOf(\'\\\'\', i = j + 2);\n\n            if (j === -1) {\n              j = s.indexOf(\'"\', i);\n\n              if (j !== -1) {\n                handleWarning(\'attribute value quote missmatch\');\n                skipAttr = true;\n              }\n            }\n\n          } else {\n            handleWarning(\'missing attribute value quotes\');\n            skipAttr = true;\n\n            // skip to next space\n            for (j = j + 1; j < l; j++) {\n              w = s.charCodeAt(j + 1);\n\n              if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE\n                break;\n              }\n            }\n\n          }\n\n          if (j === -1) {\n            handleWarning(\'missing closing quotes\');\n\n            j = l;\n            skipAttr = true;\n          }\n\n          if (!skipAttr) {\n            value = s.substring(i, j);\n          }\n\n          i = j;\n\n          // ensure SPACE follows attribute\n          // skip illegal content otherwise\n          // example a="b"c\n          for (; j + 1 < l; j++) {\n            w = s.charCodeAt(j + 1);\n\n            if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE\n              break;\n            }\n\n            // FIRST ILLEGAL CHAR\n            if (i === j) {\n              handleWarning(\'illegal character after attribute end\');\n              skipAttr = true;\n            }\n          }\n\n          // advance cursor to next attribute\n          i = j + 1;\n\n          if (skipAttr) {\n            continue parseAttr;\n          }\n\n          // check attribute re-declaration\n          if (name in seenAttrs) {\n            handleWarning(\'attribute <\' + name + \'> already defined\');\n            continue;\n          }\n\n          seenAttrs[name] = true;\n\n          if (!isNamespace) {\n            attrs[name] = value;\n            continue;\n          }\n\n          // try to extract namespace information\n          if (maybeNS) {\n            newalias = (\n              name === \'xmlns\'\n                ? \'xmlns\'\n                : (name.charCodeAt(0) === 120 && name.substr(0, 6) === \'xmlns:\')\n                  ? name.substr(6)\n                  : null\n            );\n\n            // handle xmlns(:alias) assignment\n            if (newalias !== null) {\n              nsUri = decodeEntities(value);\n              nsUriPrefix = uriPrefix(newalias);\n\n              alias = nsUriToPrefix[nsUri];\n\n              if (!alias) {\n\n                // no prefix defined or prefix collision\n                if (\n                  (newalias === \'xmlns\') ||\n                  (nsUriPrefix in nsMatrix && nsMatrix[nsUriPrefix] !== nsUri)\n                ) {\n\n                  // alocate free ns prefix\n                  do {\n                    alias = \'ns\' + (anonymousNsCount++);\n                  } while (typeof nsMatrix[alias] !== \'undefined\');\n                } else {\n                  alias = newalias;\n                }\n\n                nsUriToPrefix[nsUri] = alias;\n              }\n\n              if (nsMatrix[newalias] !== alias) {\n                if (!hasNewMatrix) {\n                  nsMatrix = cloneNsMatrix(nsMatrix);\n                  hasNewMatrix = true;\n                }\n\n                nsMatrix[newalias] = alias;\n                if (newalias === \'xmlns\') {\n                  nsMatrix[uriPrefix(alias)] = nsUri;\n                  defaultAlias = alias;\n                }\n\n                nsMatrix[nsUriPrefix] = nsUri;\n              }\n\n              // expose xmlns(:asd)="..." in attributes\n              attrs[name] = value;\n              continue;\n            }\n\n            // collect attributes until all namespace\n            // declarations are processed\n            attrList.push(name, value);\n            continue;\n\n          } /** end if (maybeNs) */\n\n          // handle attributes on element without\n          // namespace declarations\n          w = name.indexOf(\':\');\n          if (w === -1) {\n            attrs[name] = value;\n            continue;\n          }\n\n          // normalize ns attribute name\n          if (!(nsName = nsMatrix[name.substring(0, w)])) {\n            handleWarning(missingNamespaceForPrefix(name.substring(0, w)));\n            continue;\n          }\n\n          name = defaultAlias === nsName\n            ? name.substr(w + 1)\n            : nsName + name.substr(w);\n\n          // end: normalize ns attribute name\n\n          // normalize xsi:type ns attribute value\n          if (name === XSI_TYPE) {\n            w = value.indexOf(\':\');\n\n            if (w !== -1) {\n              nsName = value.substring(0, w);\n\n              // handle default prefixes, i.e. xs:String gracefully\n              nsName = nsMatrix[nsName] || nsName;\n              value = nsName + value.substring(w);\n            } else {\n              value = defaultAlias + \':\' + value;\n            }\n          }\n\n          // end: normalize xsi:type ns attribute value\n\n          attrs[name] = value;\n        }\n\n\n        // handle deferred, possibly namespaced attributes\n        if (maybeNS) {\n\n          // normalize captured attributes\n          for (i = 0, l = attrList.length; i < l; i++) {\n\n            name = attrList[i++];\n            value = attrList[i];\n\n            w = name.indexOf(\':\');\n\n            if (w !== -1) {\n\n              // normalize ns attribute name\n              if (!(nsName = nsMatrix[name.substring(0, w)])) {\n                handleWarning(missingNamespaceForPrefix(name.substring(0, w)));\n                continue;\n              }\n\n              name = defaultAlias === nsName\n                ? name.substr(w + 1)\n                : nsName + name.substr(w);\n\n              // end: normalize ns attribute name\n\n              // normalize xsi:type ns attribute value\n              if (name === XSI_TYPE) {\n                w = value.indexOf(\':\');\n\n                if (w !== -1) {\n                  nsName = value.substring(0, w);\n\n                  // handle default prefixes, i.e. xs:String gracefully\n                  nsName = nsMatrix[nsName] || nsName;\n                  value = nsName + value.substring(w);\n                } else {\n                  value = defaultAlias + \':\' + value;\n                }\n              }\n\n              // end: normalize xsi:type ns attribute value\n            }\n\n            attrs[name] = value;\n          }\n\n          // end: normalize captured attributes\n        }\n\n        return cachedAttrs = attrs;\n      }\n\n      /**\n       * Extract the parse context { line, column, part }\n       * from the current parser position.\n       *\n       * @return {Object} parse context\n       */\n      function getParseContext() {\n        var splitsRe = /(\\r\\n|\\r|\\n)/g;\n\n        var line = 0;\n        var column = 0;\n        var startOfLine = 0;\n        var endOfLine = j;\n        var match;\n        var data;\n\n        while (i >= startOfLine) {\n\n          match = splitsRe.exec(xml);\n\n          if (!match) {\n            break;\n          }\n\n          // end of line = (break idx + break chars)\n          endOfLine = match[0].length + match.index;\n\n          if (endOfLine > i) {\n            break;\n          }\n\n          // advance to next line\n          line += 1;\n\n          startOfLine = endOfLine;\n        }\n\n        // EOF errors\n        if (i == -1) {\n          column = endOfLine;\n          data = xml.substring(j);\n        } else\n\n        // start errors\n        if (j === 0) {\n          data = xml.substring(j, i);\n        }\n\n        // other errors\n        else {\n          column = i - startOfLine;\n          data = (j == -1 ? xml.substring(i) : xml.substring(i, j + 1));\n        }\n\n        return {\n          \'data\': data,\n          \'line\': line,\n          \'column\': column\n        };\n      }\n\n      getContext = getParseContext;\n\n\n      if (proxy) {\n        elementProxy = Object.create({}, {\n          \'name\': getter(function() {\n            return elementName;\n          }),\n          \'originalName\': getter(function() {\n            return _elementName;\n          }),\n          \'attrs\': getter(getAttrs),\n          \'ns\': getter(function() {\n            return nsMatrix;\n          })\n        });\n      }\n\n      // actual parse logic\n      while (j !== -1) {\n\n        if (xml.charCodeAt(j) === 60) { // "<"\n          i = j;\n        } else {\n          i = xml.indexOf(\'<\', j);\n        }\n\n        // parse end\n        if (i === -1) {\n          if (nodeStack.length) {\n            return handleError(\'unexpected end of file\');\n          }\n\n          if (j === 0) {\n            return handleError(\'missing start tag\');\n          }\n\n          if (j < xml.length) {\n            if (xml.substring(j).trim()) {\n              handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);\n            }\n          }\n\n          return;\n        }\n\n        // parse text\n        if (j !== i) {\n\n          if (nodeStack.length) {\n            if (onText) {\n              onText(xml.substring(j, i), decodeEntities, getContext);\n\n              if (parseStop) {\n                return;\n              }\n            }\n          } else {\n            if (xml.substring(j, i).trim()) {\n              handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);\n\n              if (parseStop) {\n                return;\n              }\n            }\n          }\n        }\n\n        w = xml.charCodeAt(i+1);\n\n        // parse comments + CDATA\n        if (w === 33) { // "!"\n          q = xml.charCodeAt(i+2);\n\n          // CDATA section\n          if (q === 91 && xml.substr(i + 3, 6) === \'CDATA[\') { // 91 == "["\n            j = xml.indexOf(\']]>\', i);\n            if (j === -1) {\n              return handleError(\'unclosed cdata\');\n            }\n\n            if (onCDATA) {\n              onCDATA(xml.substring(i + 9, j), getContext);\n              if (parseStop) {\n                return;\n              }\n            }\n\n            j += 3;\n            continue;\n          }\n\n          // comment\n          if (q === 45 && xml.charCodeAt(i + 3) === 45) { // 45 == "-"\n            j = xml.indexOf(\'--\x3e\', i);\n            if (j === -1) {\n              return handleError(\'unclosed comment\');\n            }\n\n\n            if (onComment) {\n              onComment(xml.substring(i + 4, j), decodeEntities, getContext);\n              if (parseStop) {\n                return;\n              }\n            }\n\n            j += 3;\n            continue;\n          }\n        }\n\n        // parse question <? ... ?>\n        if (w === 63) { // "?"\n          j = xml.indexOf(\'?>\', i);\n          if (j === -1) {\n            return handleError(\'unclosed question\');\n          }\n\n          if (onQuestion) {\n            onQuestion(xml.substring(i, j + 2), getContext);\n            if (parseStop) {\n              return;\n            }\n          }\n\n          j += 2;\n          continue;\n        }\n\n        // find matching closing tag for attention or standard tags\n        // for that we must skip through attribute values\n        // (enclosed in single or double quotes)\n        for (x = i + 1; ; x++) {\n          v = xml.charCodeAt(x);\n          if (isNaN(v)) {\n            j = -1;\n            return handleError(\'unclosed tag\');\n          }\n\n          // [10] AttValue ::= \'"\' ([^<&"] | Reference)* \'"\' | "\'" ([^<&\'] | Reference)* "\'"\n          // skips the quoted string\n          // (double quotes) does not appear in a literal enclosed by (double quotes)\n          // (single quote) does not appear in a literal enclosed by (single quote)\n          if (v === 34) { //  \'"\'\n            q = xml.indexOf(\'"\', x + 1);\n            x = q !== -1 ? q : x;\n          } else if (v === 39) { // "\'"\n            q = xml.indexOf("\'", x + 1);\n            x = q !== -1 ? q : x;\n          } else if (v === 62) { // \'>\'\n            j = x;\n            break;\n          }\n        }\n\n\n        // parse attention <! ...>\n        // previously comment and CDATA have already been parsed\n        if (w === 33) { // "!"\n\n          if (onAttention) {\n            onAttention(xml.substring(i, j + 1), decodeEntities, getContext);\n            if (parseStop) {\n              return;\n            }\n          }\n\n          j += 1;\n          continue;\n        }\n\n        // don\'t process attributes;\n        // there are none\n        cachedAttrs = {};\n\n        // if (xml.charCodeAt(i+1) === 47) { // </...\n        if (w === 47) { // </...\n          tagStart = false;\n          tagEnd = true;\n\n          if (!nodeStack.length) {\n            return handleError(\'missing open tag\');\n          }\n\n          // verify open <-> close tag match\n          x = elementName = nodeStack.pop();\n          q = i + 2 + x.length;\n\n          if (xml.substring(i + 2, q) !== x) {\n            return handleError(\'closing tag mismatch\');\n          }\n\n          // verify chars in close tag\n          for (; q < j; q++) {\n            w = xml.charCodeAt(q);\n\n            if (w === 32 || (w > 8 && w < 14)) { // \\f\\n\\r\\t\\v space\n              continue;\n            }\n\n            return handleError(\'close tag\');\n          }\n\n        } else {\n          if (xml.charCodeAt(j - 1) === 47) { // .../>\n            x = elementName = xml.substring(i + 1, j - 1);\n\n            tagStart = true;\n            tagEnd = true;\n\n          } else {\n            x = elementName = xml.substring(i + 1, j);\n\n            tagStart = true;\n            tagEnd = false;\n          }\n\n          if (!(w > 96 && w < 123 || w > 64 && w < 91 || w === 95 || w === 58)) { // char 95"_" 58":"\n            return handleError(\'illegal first char nodeName\');\n          }\n\n          for (q = 1, y = x.length; q < y; q++) {\n            w = x.charCodeAt(q);\n\n            if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 45 || w === 95 || w == 46) {\n              continue;\n            }\n\n            if (w === 32 || (w < 14 && w > 8)) { // \\f\\n\\r\\t\\v space\n              elementName = x.substring(0, q);\n\n              // maybe there are attributes\n              cachedAttrs = null;\n              break;\n            }\n\n            return handleError(\'invalid nodeName\');\n          }\n\n          if (!tagEnd) {\n            nodeStack.push(elementName);\n          }\n        }\n\n        if (isNamespace) {\n\n          _nsMatrix = nsMatrix;\n\n          if (tagStart) {\n\n            // remember old namespace\n            // unless we\'re self-closing\n            if (!tagEnd) {\n              nsMatrixStack.push(_nsMatrix);\n            }\n\n            if (cachedAttrs === null) {\n\n              // quick check, whether there may be namespace\n              // declarations on the node; if that is the case\n              // we need to eagerly parse the node attributes\n              if ((maybeNS = x.indexOf(\'xmlns\', q) !== -1)) {\n                attrsStart = q;\n                attrsString = x;\n\n                getAttrs();\n\n                maybeNS = false;\n              }\n            }\n          }\n\n          _elementName = elementName;\n\n          w = elementName.indexOf(\':\');\n          if (w !== -1) {\n            xmlns = nsMatrix[elementName.substring(0, w)];\n\n            // prefix given; namespace must exist\n            if (!xmlns) {\n              return handleError(\'missing namespace on <\' + _elementName + \'>\');\n            }\n\n            elementName = elementName.substr(w + 1);\n          } else {\n            xmlns = nsMatrix[\'xmlns\'];\n\n            // if no default namespace is defined,\n            // we\'ll import the element as anonymous.\n            //\n            // it is up to users to correct that to the document defined\n            // targetNamespace, or whatever their undersanding of the\n            // XML spec mandates.\n          }\n\n          // adjust namespace prefixs as configured\n          if (xmlns) {\n            elementName = xmlns + \':\' + elementName;\n          }\n\n        }\n\n        if (tagStart) {\n          attrsStart = q;\n          attrsString = x;\n\n          if (onOpenTag) {\n            if (proxy) {\n              onOpenTag(elementProxy, decodeEntities, tagEnd, getContext);\n            } else {\n              onOpenTag(elementName, getAttrs, decodeEntities, tagEnd, getContext);\n            }\n\n            if (parseStop) {\n              return;\n            }\n          }\n\n        }\n\n        if (tagEnd) {\n\n          if (onCloseTag) {\n            onCloseTag(proxy ? elementProxy : elementName, decodeEntities, tagStart, getContext);\n\n            if (parseStop) {\n              return;\n            }\n          }\n\n          // restore old namespace\n          if (isNamespace) {\n            if (!tagStart) {\n              nsMatrix = nsMatrixStack.pop();\n            } else {\n              nsMatrix = _nsMatrix;\n            }\n          }\n        }\n\n        j += 1;\n      }\n    } /** end parse */\n\n  }\n\n  function hasLowerCaseAlias(pkg) {\n    return pkg.xml && pkg.xml.tagAlias === \'lowerCase\';\n  }\n\n  var DEFAULT_NS_MAP = {\n    \'xsi\': \'http://www.w3.org/2001/XMLSchema-instance\',\n    \'xml\': \'http://www.w3.org/XML/1998/namespace\'\n  };\n\n  var XSI_TYPE$1 = \'xsi:type\';\n\n  function serializeFormat(element) {\n    return element.xml && element.xml.serialize;\n  }\n\n  function serializeAsType(element) {\n    return serializeFormat(element) === XSI_TYPE$1;\n  }\n\n  function serializeAsProperty(element) {\n    return serializeFormat(element) === \'property\';\n  }\n\n  function capitalize(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  }\n\n  function aliasToName(aliasNs, pkg) {\n\n    if (!hasLowerCaseAlias(pkg)) {\n      return aliasNs.name;\n    }\n\n    return aliasNs.prefix + \':\' + capitalize(aliasNs.localName);\n  }\n\n  function prefixedToName(nameNs, pkg) {\n\n    var name = nameNs.name,\n        localName = nameNs.localName;\n\n    var typePrefix = pkg.xml && pkg.xml.typePrefix;\n\n    if (typePrefix && localName.indexOf(typePrefix) === 0) {\n      return nameNs.prefix + \':\' + localName.slice(typePrefix.length);\n    } else {\n      return name;\n    }\n  }\n\n  function normalizeXsiTypeName(name, model) {\n\n    var nameNs = parseName(name);\n    var pkg = model.getPackage(nameNs.prefix);\n\n    return prefixedToName(nameNs, pkg);\n  }\n\n  function error$1(message) {\n    return new Error(message);\n  }\n\n  /**\n   * Get the moddle descriptor for a given instance or type.\n   *\n   * @param  {ModdleElement|Function} element\n   *\n   * @return {Object} the moddle descriptor\n   */\n  function getModdleDescriptor(element) {\n    return element.$descriptor;\n  }\n\n\n  /**\n   * A parse context.\n   *\n   * @class\n   *\n   * @param {Object} options\n   * @param {ElementHandler} options.rootHandler the root handler for parsing a document\n   * @param {boolean} [options.lax=false] whether or not to ignore invalid elements\n   */\n  function Context(options) {\n\n    /**\n     * @property {ElementHandler} rootHandler\n     */\n\n    /**\n     * @property {Boolean} lax\n     */\n\n    assign(this, options);\n\n    this.elementsById = {};\n    this.references = [];\n    this.warnings = [];\n\n    /**\n     * Add an unresolved reference.\n     *\n     * @param {Object} reference\n     */\n    this.addReference = function(reference) {\n      this.references.push(reference);\n    };\n\n    /**\n     * Add a processed element.\n     *\n     * @param {ModdleElement} element\n     */\n    this.addElement = function(element) {\n\n      if (!element) {\n        throw error$1(\'expected element\');\n      }\n\n      var elementsById = this.elementsById;\n\n      var descriptor = getModdleDescriptor(element);\n\n      var idProperty = descriptor.idProperty,\n          id;\n\n      if (idProperty) {\n        id = element.get(idProperty.name);\n\n        if (id) {\n\n          // for QName validation as per http://www.w3.org/TR/REC-xml/#NT-NameChar\n          if (!/^([a-z][\\w-.]*:)?[a-z_][\\w-.]*$/i.test(id)) {\n            throw new Error(\'illegal ID <\' + id + \'>\');\n          }\n\n          if (elementsById[id]) {\n            throw error$1(\'duplicate ID <\' + id + \'>\');\n          }\n\n          elementsById[id] = element;\n        }\n      }\n    };\n\n    /**\n     * Add an import warning.\n     *\n     * @param {Object} warning\n     * @param {String} warning.message\n     * @param {Error} [warning.error]\n     */\n    this.addWarning = function(warning) {\n      this.warnings.push(warning);\n    };\n  }\n\n  function BaseHandler() {}\n\n  BaseHandler.prototype.handleEnd = function() {};\n  BaseHandler.prototype.handleText = function() {};\n  BaseHandler.prototype.handleNode = function() {};\n\n\n  /**\n   * A simple pass through handler that does nothing except for\n   * ignoring all input it receives.\n   *\n   * This is used to ignore unknown elements and\n   * attributes.\n   */\n  function NoopHandler() { }\n\n  NoopHandler.prototype = Object.create(BaseHandler.prototype);\n\n  NoopHandler.prototype.handleNode = function() {\n    return this;\n  };\n\n  function BodyHandler() {}\n\n  BodyHandler.prototype = Object.create(BaseHandler.prototype);\n\n  BodyHandler.prototype.handleText = function(text) {\n    this.body = (this.body || \'\') + text;\n  };\n\n  function ReferenceHandler(property, context) {\n    this.property = property;\n    this.context = context;\n  }\n\n  ReferenceHandler.prototype = Object.create(BodyHandler.prototype);\n\n  ReferenceHandler.prototype.handleNode = function(node) {\n\n    if (this.element) {\n      throw error$1(\'expected no sub nodes\');\n    } else {\n      this.element = this.createReference(node);\n    }\n\n    return this;\n  };\n\n  ReferenceHandler.prototype.handleEnd = function() {\n    this.element.id = this.body;\n  };\n\n  ReferenceHandler.prototype.createReference = function(node) {\n    return {\n      property: this.property.ns.name,\n      id: \'\'\n    };\n  };\n\n  function ValueHandler(propertyDesc, element) {\n    this.element = element;\n    this.propertyDesc = propertyDesc;\n  }\n\n  ValueHandler.prototype = Object.create(BodyHandler.prototype);\n\n  ValueHandler.prototype.handleEnd = function() {\n\n    var value = this.body || \'\',\n        element = this.element,\n        propertyDesc = this.propertyDesc;\n\n    value = coerceType(propertyDesc.type, value);\n\n    if (propertyDesc.isMany) {\n      element.get(propertyDesc.name).push(value);\n    } else {\n      element.set(propertyDesc.name, value);\n    }\n  };\n\n\n  function BaseElementHandler() {}\n\n  BaseElementHandler.prototype = Object.create(BodyHandler.prototype);\n\n  BaseElementHandler.prototype.handleNode = function(node) {\n    var parser = this,\n        element = this.element;\n\n    if (!element) {\n      element = this.element = this.createElement(node);\n\n      this.context.addElement(element);\n    } else {\n      parser = this.handleChild(node);\n    }\n\n    return parser;\n  };\n\n  /**\n   * @class Reader.ElementHandler\n   *\n   */\n  function ElementHandler(model, typeName, context) {\n    this.model = model;\n    this.type = model.getType(typeName);\n    this.context = context;\n  }\n\n  ElementHandler.prototype = Object.create(BaseElementHandler.prototype);\n\n  ElementHandler.prototype.addReference = function(reference) {\n    this.context.addReference(reference);\n  };\n\n  ElementHandler.prototype.handleText = function(text) {\n\n    var element = this.element,\n        descriptor = getModdleDescriptor(element),\n        bodyProperty = descriptor.bodyProperty;\n\n    if (!bodyProperty) {\n      throw error$1(\'unexpected body text <\' + text + \'>\');\n    }\n\n    BodyHandler.prototype.handleText.call(this, text);\n  };\n\n  ElementHandler.prototype.handleEnd = function() {\n\n    var value = this.body,\n        element = this.element,\n        descriptor = getModdleDescriptor(element),\n        bodyProperty = descriptor.bodyProperty;\n\n    if (bodyProperty && value !== undefined) {\n      value = coerceType(bodyProperty.type, value);\n      element.set(bodyProperty.name, value);\n    }\n  };\n\n  /**\n   * Create an instance of the model from the given node.\n   *\n   * @param  {Element} node the xml node\n   */\n  ElementHandler.prototype.createElement = function(node) {\n    var attributes = node.attributes,\n        Type = this.type,\n        descriptor = getModdleDescriptor(Type),\n        context = this.context,\n        instance = new Type({}),\n        model = this.model,\n        propNameNs;\n\n    forEach(attributes, function(value, name) {\n\n      var prop = descriptor.propertiesByName[name],\n          values;\n\n      if (prop && prop.isReference) {\n\n        if (!prop.isMany) {\n          context.addReference({\n            element: instance,\n            property: prop.ns.name,\n            id: value\n          });\n        } else {\n\n          // IDREFS: parse references as whitespace-separated list\n          values = value.split(\' \');\n\n          forEach(values, function(v) {\n            context.addReference({\n              element: instance,\n              property: prop.ns.name,\n              id: v\n            });\n          });\n        }\n\n      } else {\n        if (prop) {\n          value = coerceType(prop.type, value);\n        } else\n        if (name !== \'xmlns\') {\n          propNameNs = parseName(name, descriptor.ns.prefix);\n\n          // check whether attribute is defined in a well-known namespace\n          // if that is the case we emit a warning to indicate potential misuse\n          if (model.getPackage(propNameNs.prefix)) {\n\n            context.addWarning({\n              message: \'unknown attribute <\' + name + \'>\',\n              element: instance,\n              property: name,\n              value: value\n            });\n          }\n        }\n\n        instance.set(name, value);\n      }\n    });\n\n    return instance;\n  };\n\n  ElementHandler.prototype.getPropertyForNode = function(node) {\n\n    var name = node.name;\n    var nameNs = parseName(name);\n\n    var type = this.type,\n        model = this.model,\n        descriptor = getModdleDescriptor(type);\n\n    var propertyName = nameNs.name,\n        property = descriptor.propertiesByName[propertyName],\n        elementTypeName,\n        elementType;\n\n    // search for properties by name first\n\n    if (property && !property.isAttr) {\n\n      if (serializeAsType(property)) {\n        elementTypeName = node.attributes[XSI_TYPE$1];\n\n        // xsi type is optional, if it does not exists the\n        // default type is assumed\n        if (elementTypeName) {\n\n          // take possible type prefixes from XML\n          // into account, i.e.: xsi:type="t{ActualType}"\n          elementTypeName = normalizeXsiTypeName(elementTypeName, model);\n\n          elementType = model.getType(elementTypeName);\n\n          return assign({}, property, {\n            effectiveType: getModdleDescriptor(elementType).name\n          });\n        }\n      }\n\n      // search for properties by name first\n      return property;\n    }\n\n    var pkg = model.getPackage(nameNs.prefix);\n\n    if (pkg) {\n      elementTypeName = aliasToName(nameNs, pkg);\n      elementType = model.getType(elementTypeName);\n\n      // search for collection members later\n      property = find(descriptor.properties, function(p) {\n        return !p.isVirtual && !p.isReference && !p.isAttribute && elementType.hasType(p.type);\n      });\n\n      if (property) {\n        return assign({}, property, {\n          effectiveType: getModdleDescriptor(elementType).name\n        });\n      }\n    } else {\n\n      // parse unknown element (maybe extension)\n      property = find(descriptor.properties, function(p) {\n        return !p.isReference && !p.isAttribute && p.type === \'Element\';\n      });\n\n      if (property) {\n        return property;\n      }\n    }\n\n    throw error$1(\'unrecognized element <\' + nameNs.name + \'>\');\n  };\n\n  ElementHandler.prototype.toString = function() {\n    return \'ElementDescriptor[\' + getModdleDescriptor(this.type).name + \']\';\n  };\n\n  ElementHandler.prototype.valueHandler = function(propertyDesc, element) {\n    return new ValueHandler(propertyDesc, element);\n  };\n\n  ElementHandler.prototype.referenceHandler = function(propertyDesc) {\n    return new ReferenceHandler(propertyDesc, this.context);\n  };\n\n  ElementHandler.prototype.handler = function(type) {\n    if (type === \'Element\') {\n      return new GenericElementHandler(this.model, type, this.context);\n    } else {\n      return new ElementHandler(this.model, type, this.context);\n    }\n  };\n\n  /**\n   * Handle the child element parsing\n   *\n   * @param  {Element} node the xml node\n   */\n  ElementHandler.prototype.handleChild = function(node) {\n    var propertyDesc, type, element, childHandler;\n\n    propertyDesc = this.getPropertyForNode(node);\n    element = this.element;\n\n    type = propertyDesc.effectiveType || propertyDesc.type;\n\n    if (isSimple(type)) {\n      return this.valueHandler(propertyDesc, element);\n    }\n\n    if (propertyDesc.isReference) {\n      childHandler = this.referenceHandler(propertyDesc).handleNode(node);\n    } else {\n      childHandler = this.handler(type).handleNode(node);\n    }\n\n    var newElement = childHandler.element;\n\n    // child handles may decide to skip elements\n    // by not returning anything\n    if (newElement !== undefined) {\n\n      if (propertyDesc.isMany) {\n        element.get(propertyDesc.name).push(newElement);\n      } else {\n        element.set(propertyDesc.name, newElement);\n      }\n\n      if (propertyDesc.isReference) {\n        assign(newElement, {\n          element: element\n        });\n\n        this.context.addReference(newElement);\n      } else {\n\n        // establish child -> parent relationship\n        newElement.$parent = element;\n      }\n    }\n\n    return childHandler;\n  };\n\n  /**\n   * An element handler that performs special validation\n   * to ensure the node it gets initialized with matches\n   * the handlers type (namespace wise).\n   *\n   * @param {Moddle} model\n   * @param {String} typeName\n   * @param {Context} context\n   */\n  function RootElementHandler(model, typeName, context) {\n    ElementHandler.call(this, model, typeName, context);\n  }\n\n  RootElementHandler.prototype = Object.create(ElementHandler.prototype);\n\n  RootElementHandler.prototype.createElement = function(node) {\n\n    var name = node.name,\n        nameNs = parseName(name),\n        model = this.model,\n        type = this.type,\n        pkg = model.getPackage(nameNs.prefix),\n        typeName = pkg && aliasToName(nameNs, pkg) || name;\n\n    // verify the correct namespace if we parse\n    // the first element in the handler tree\n    //\n    // this ensures we don\'t mistakenly import wrong namespace elements\n    if (!type.hasType(typeName)) {\n      throw error$1(\'unexpected element <\' + node.originalName + \'>\');\n    }\n\n    return ElementHandler.prototype.createElement.call(this, node);\n  };\n\n\n  function GenericElementHandler(model, typeName, context) {\n    this.model = model;\n    this.context = context;\n  }\n\n  GenericElementHandler.prototype = Object.create(BaseElementHandler.prototype);\n\n  GenericElementHandler.prototype.createElement = function(node) {\n\n    var name = node.name,\n        ns = parseName(name),\n        prefix = ns.prefix,\n        uri = node.ns[prefix + \'$uri\'],\n        attributes = node.attributes;\n\n    return this.model.createAny(name, uri, attributes);\n  };\n\n  GenericElementHandler.prototype.handleChild = function(node) {\n\n    var handler = new GenericElementHandler(this.model, \'Element\', this.context).handleNode(node),\n        element = this.element;\n\n    var newElement = handler.element,\n        children;\n\n    if (newElement !== undefined) {\n      children = element.$children = element.$children || [];\n      children.push(newElement);\n\n      // establish child -> parent relationship\n      newElement.$parent = element;\n    }\n\n    return handler;\n  };\n\n  GenericElementHandler.prototype.handleEnd = function() {\n    if (this.body) {\n      this.element.$body = this.body;\n    }\n  };\n\n  /**\n   * A reader for a meta-model\n   *\n   * @param {Object} options\n   * @param {Model} options.model used to read xml files\n   * @param {Boolean} options.lax whether to make parse errors warnings\n   */\n  function Reader(options) {\n\n    if (options instanceof Moddle) {\n      options = {\n        model: options\n      };\n    }\n\n    assign(this, { lax: false }, options);\n  }\n\n  /**\n   * The fromXML result.\n   *\n   * @typedef {Object} ParseResult\n   *\n   * @property {ModdleElement} rootElement\n   * @property {Array<Object>} references\n   * @property {Array<Error>} warnings\n   * @property {Object} elementsById - a mapping containing each ID -> ModdleElement\n   */\n\n  /**\n   * The fromXML result.\n   *\n   * @typedef {Error} ParseError\n   *\n   * @property {Array<Error>} warnings\n   */\n\n  /**\n   * Parse the given XML into a moddle document tree.\n   *\n   * @param {String} xml\n   * @param {ElementHandler|Object} options or rootHandler\n   *\n   * @returns {Promise<ParseResult, ParseError>}\n   */\n  Reader.prototype.fromXML = function(xml, options, done) {\n\n    var rootHandler = options.rootHandler;\n\n    if (options instanceof ElementHandler) {\n\n      // root handler passed via (xml, { rootHandler: ElementHandler }, ...)\n      rootHandler = options;\n      options = {};\n    } else {\n      if (typeof options === \'string\') {\n\n        // rootHandler passed via (xml, \'someString\', ...)\n        rootHandler = this.handler(options);\n        options = {};\n      } else if (typeof rootHandler === \'string\') {\n\n        // rootHandler passed via (xml, { rootHandler: \'someString\' }, ...)\n        rootHandler = this.handler(rootHandler);\n      }\n    }\n\n    var model = this.model,\n        lax = this.lax;\n\n    var context = new Context(assign({}, options, { rootHandler: rootHandler })),\n        parser = new Parser({ proxy: true }),\n        stack = createStack();\n\n    rootHandler.context = context;\n\n    // push root handler\n    stack.push(rootHandler);\n\n\n    /**\n     * Handle error.\n     *\n     * @param  {Error} err\n     * @param  {Function} getContext\n     * @param  {boolean} lax\n     *\n     * @return {boolean} true if handled\n     */\n    function handleError(err, getContext, lax) {\n\n      var ctx = getContext();\n\n      var line = ctx.line,\n          column = ctx.column,\n          data = ctx.data;\n\n      // we receive the full context data here,\n      // for elements trim down the information\n      // to the tag name, only\n      if (data.charAt(0) === \'<\' && data.indexOf(\' \') !== -1) {\n        data = data.slice(0, data.indexOf(\' \')) + \'>\';\n      }\n\n      var message =\n        \'unparsable content \' + (data ? data + \' \' : \'\') + \'detected\\n\\t\' +\n          \'line: \' + line + \'\\n\\t\' +\n          \'column: \' + column + \'\\n\\t\' +\n          \'nested error: \' + err.message;\n\n      if (lax) {\n        context.addWarning({\n          message: message,\n          error: err\n        });\n\n        return true;\n      } else {\n        throw error$1(message);\n      }\n    }\n\n    function handleWarning(err, getContext) {\n\n      // just like handling errors in <lax=true> mode\n      return handleError(err, getContext, true);\n    }\n\n    /**\n     * Resolve collected references on parse end.\n     */\n    function resolveReferences() {\n\n      var elementsById = context.elementsById;\n      var references = context.references;\n\n      var i, r;\n\n      for (i = 0; (r = references[i]); i++) {\n        var element = r.element;\n        var reference = elementsById[r.id];\n        var property = getModdleDescriptor(element).propertiesByName[r.property];\n\n        if (!reference) {\n          context.addWarning({\n            message: \'unresolved reference <\' + r.id + \'>\',\n            element: r.element,\n            property: r.property,\n            value: r.id\n          });\n        }\n\n        if (property.isMany) {\n          var collection = element.get(property.name),\n              idx = collection.indexOf(r);\n\n          // we replace an existing place holder (idx != -1) or\n          // append to the collection instead\n          if (idx === -1) {\n            idx = collection.length;\n          }\n\n          if (!reference) {\n\n            // remove unresolvable reference\n            collection.splice(idx, 1);\n          } else {\n\n            // add or update reference in collection\n            collection[idx] = reference;\n          }\n        } else {\n          element.set(property.name, reference);\n        }\n      }\n    }\n\n    function handleClose() {\n      stack.pop().handleEnd();\n    }\n\n    var PREAMBLE_START_PATTERN = /^<\\?xml /i;\n\n    var ENCODING_PATTERN = / encoding="([^"]+)"/i;\n\n    var UTF_8_PATTERN = /^utf-8$/i;\n\n    function handleQuestion(question) {\n\n      if (!PREAMBLE_START_PATTERN.test(question)) {\n        return;\n      }\n\n      var match = ENCODING_PATTERN.exec(question);\n      var encoding = match && match[1];\n\n      if (!encoding || UTF_8_PATTERN.test(encoding)) {\n        return;\n      }\n\n      context.addWarning({\n        message:\n          \'unsupported document encoding <\' + encoding + \'>, \' +\n          \'falling back to UTF-8\'\n      });\n    }\n\n    function handleOpen(node, getContext) {\n      var handler = stack.peek();\n\n      try {\n        stack.push(handler.handleNode(node));\n      } catch (err) {\n\n        if (handleError(err, getContext, lax)) {\n          stack.push(new NoopHandler());\n        }\n      }\n    }\n\n    function handleCData(text, getContext) {\n\n      try {\n        stack.peek().handleText(text);\n      } catch (err) {\n        handleWarning(err, getContext);\n      }\n    }\n\n    function handleText(text, getContext) {\n\n      // strip whitespace only nodes, i.e. before\n      // <!CDATA[ ... ]> sections and in between tags\n\n      if (!text.trim()) {\n        return;\n      }\n\n      handleCData(text, getContext);\n    }\n\n    var uriMap = model.getPackages().reduce(function(uriMap, p) {\n      uriMap[p.uri] = p.prefix;\n\n      return uriMap;\n    }, {\n      \'http://www.w3.org/XML/1998/namespace\': \'xml\' // add default xml ns\n    });\n    parser\n      .ns(uriMap)\n      .on(\'openTag\', function(obj, decodeStr, selfClosing, getContext) {\n\n        // gracefully handle unparsable attributes (attrs=false)\n        var attrs = obj.attrs || {};\n\n        var decodedAttrs = Object.keys(attrs).reduce(function(d, key) {\n          var value = decodeStr(attrs[key]);\n\n          d[key] = value;\n\n          return d;\n        }, {});\n\n        var node = {\n          name: obj.name,\n          originalName: obj.originalName,\n          attributes: decodedAttrs,\n          ns: obj.ns\n        };\n\n        handleOpen(node, getContext);\n      })\n      .on(\'question\', handleQuestion)\n      .on(\'closeTag\', handleClose)\n      .on(\'cdata\', handleCData)\n      .on(\'text\', function(text, decodeEntities, getContext) {\n        handleText(decodeEntities(text), getContext);\n      })\n      .on(\'error\', handleError)\n      .on(\'warn\', handleWarning);\n\n    // async XML parsing to make sure the execution environment\n    // (node or brower) is kept responsive and that certain optimization\n    // strategies can kick in.\n    return new Promise(function(resolve, reject) {\n\n      var err;\n\n      try {\n        parser.parse(xml);\n\n        resolveReferences();\n      } catch (e) {\n        err = e;\n      }\n\n      var rootElement = rootHandler.element;\n\n      if (!err && !rootElement) {\n        err = error$1(\'failed to parse document as <\' + rootHandler.type.$descriptor.name + \'>\');\n      }\n\n      var warnings = context.warnings;\n      var references = context.references;\n      var elementsById = context.elementsById;\n\n      if (err) {\n        err.warnings = warnings;\n\n        return reject(err);\n      } else {\n        return resolve({\n          rootElement: rootElement,\n          elementsById: elementsById,\n          references: references,\n          warnings: warnings\n        });\n      }\n    });\n  };\n\n  Reader.prototype.handler = function(name) {\n    return new RootElementHandler(this.model, name);\n  };\n\n\n  // helpers //////////////////////////\n\n  function createStack() {\n    var stack = [];\n\n    Object.defineProperty(stack, \'peek\', {\n      value: function() {\n        return this[this.length - 1];\n      }\n    });\n\n    return stack;\n  }\n\n  var XML_PREAMBLE = \'<?xml version="1.0" encoding="UTF-8"?>\\n\';\n\n  var ESCAPE_ATTR_CHARS = /<|>|\'|"|&|\\n\\r|\\n/g;\n  var ESCAPE_CHARS = /<|>|&/g;\n\n\n  function Namespaces(parent) {\n\n    var prefixMap = {};\n    var uriMap = {};\n    var used = {};\n\n    var wellknown = [];\n    var custom = [];\n\n    // API\n\n    this.byUri = function(uri) {\n      return uriMap[uri] || (\n        parent && parent.byUri(uri)\n      );\n    };\n\n    this.add = function(ns, isWellknown) {\n\n      uriMap[ns.uri] = ns;\n\n      if (isWellknown) {\n        wellknown.push(ns);\n      } else {\n        custom.push(ns);\n      }\n\n      this.mapPrefix(ns.prefix, ns.uri);\n    };\n\n    this.uriByPrefix = function(prefix) {\n      return prefixMap[prefix || \'xmlns\'];\n    };\n\n    this.mapPrefix = function(prefix, uri) {\n      prefixMap[prefix || \'xmlns\'] = uri;\n    };\n\n    this.getNSKey = function(ns) {\n      return (ns.prefix !== undefined) ? (ns.uri + \'|\' + ns.prefix) : ns.uri;\n    };\n\n    this.logUsed = function(ns) {\n\n      var uri = ns.uri;\n      var nsKey = this.getNSKey(ns);\n\n      used[nsKey] = this.byUri(uri);\n\n      // Inform parent recursively about the usage of this NS\n      if (parent) {\n        parent.logUsed(ns);\n      }\n    };\n\n    this.getUsed = function(ns) {\n\n      function isUsed(ns) {\n        var nsKey = self.getNSKey(ns);\n\n        return used[nsKey];\n      }\n\n      var self = this;\n\n      var allNs = [].concat(wellknown, custom);\n\n      return allNs.filter(isUsed);\n    };\n\n  }\n\n  function lower(string) {\n    return string.charAt(0).toLowerCase() + string.slice(1);\n  }\n\n  function nameToAlias(name, pkg) {\n    if (hasLowerCaseAlias(pkg)) {\n      return lower(name);\n    } else {\n      return name;\n    }\n  }\n\n  function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor;\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  }\n\n  function nsName(ns) {\n    if (isString(ns)) {\n      return ns;\n    } else {\n      return (ns.prefix ? ns.prefix + \':\' : \'\') + ns.localName;\n    }\n  }\n\n  function getNsAttrs(namespaces) {\n\n    return namespaces.getUsed().filter(function(ns) {\n\n      // do not serialize built in <xml> namespace\n      return ns.prefix !== \'xml\';\n    }).map(function(ns) {\n      var name = \'xmlns\' + (ns.prefix ? \':\' + ns.prefix : \'\');\n      return { name: name, value: ns.uri };\n    });\n\n  }\n\n  function getElementNs(ns, descriptor) {\n    if (descriptor.isGeneric) {\n      return assign({ localName: descriptor.ns.localName }, ns);\n    } else {\n      return assign({ localName: nameToAlias(descriptor.ns.localName, descriptor.$pkg) }, ns);\n    }\n  }\n\n  function getPropertyNs(ns, descriptor) {\n    return assign({ localName: descriptor.ns.localName }, ns);\n  }\n\n  function getSerializableProperties(element) {\n    var descriptor = element.$descriptor;\n\n    return filter(descriptor.properties, function(p) {\n      var name = p.name;\n\n      if (p.isVirtual) {\n        return false;\n      }\n\n      // do not serialize defaults\n      if (!has(element, name)) {\n        return false;\n      }\n\n      var value = element[name];\n\n      // do not serialize default equals\n      if (value === p.default) {\n        return false;\n      }\n\n      // do not serialize null properties\n      if (value === null) {\n        return false;\n      }\n\n      return p.isMany ? value.length : true;\n    });\n  }\n\n  var ESCAPE_ATTR_MAP = {\n    \'\\n\': \'#10\',\n    \'\\n\\r\': \'#10\',\n    \'"\': \'#34\',\n    \'\\\'\': \'#39\',\n    \'<\': \'#60\',\n    \'>\': \'#62\',\n    \'&\': \'#38\'\n  };\n\n  var ESCAPE_MAP = {\n    \'<\': \'lt\',\n    \'>\': \'gt\',\n    \'&\': \'amp\'\n  };\n\n  function escape(str, charPattern, replaceMap) {\n\n    // ensure we are handling strings here\n    str = isString(str) ? str : \'\' + str;\n\n    return str.replace(charPattern, function(s) {\n      return \'&\' + replaceMap[s] + \';\';\n    });\n  }\n\n  /**\n   * Escape a string attribute to not contain any bad values (line breaks, \'"\', ...)\n   *\n   * @param {String} str the string to escape\n   * @return {String} the escaped string\n   */\n  function escapeAttr(str) {\n    return escape(str, ESCAPE_ATTR_CHARS, ESCAPE_ATTR_MAP);\n  }\n\n  function escapeBody(str) {\n    return escape(str, ESCAPE_CHARS, ESCAPE_MAP);\n  }\n\n  function filterAttributes(props) {\n    return filter(props, function(p) { return p.isAttr; });\n  }\n\n  function filterContained(props) {\n    return filter(props, function(p) { return !p.isAttr; });\n  }\n\n\n  function ReferenceSerializer(tagName) {\n    this.tagName = tagName;\n  }\n\n  ReferenceSerializer.prototype.build = function(element) {\n    this.element = element;\n    return this;\n  };\n\n  ReferenceSerializer.prototype.serializeTo = function(writer) {\n    writer\n      .appendIndent()\n      .append(\'<\' + this.tagName + \'>\' + this.element.id + \'</\' + this.tagName + \'>\')\n      .appendNewLine();\n  };\n\n  function BodySerializer() {}\n\n  BodySerializer.prototype.serializeValue =\n  BodySerializer.prototype.serializeTo = function(writer) {\n    writer.append(\n      this.escape\n        ? escapeBody(this.value)\n        : this.value\n    );\n  };\n\n  BodySerializer.prototype.build = function(prop, value) {\n    this.value = value;\n\n    if (prop.type === \'String\' && value.search(ESCAPE_CHARS) !== -1) {\n      this.escape = true;\n    }\n\n    return this;\n  };\n\n  function ValueSerializer(tagName) {\n    this.tagName = tagName;\n  }\n\n  inherits(ValueSerializer, BodySerializer);\n\n  ValueSerializer.prototype.serializeTo = function(writer) {\n\n    writer\n      .appendIndent()\n      .append(\'<\' + this.tagName + \'>\');\n\n    this.serializeValue(writer);\n\n    writer\n      .append(\'</\' + this.tagName + \'>\')\n      .appendNewLine();\n  };\n\n  function ElementSerializer(parent, propertyDescriptor) {\n    this.body = [];\n    this.attrs = [];\n\n    this.parent = parent;\n    this.propertyDescriptor = propertyDescriptor;\n  }\n\n  ElementSerializer.prototype.build = function(element) {\n    this.element = element;\n\n    var elementDescriptor = element.$descriptor,\n        propertyDescriptor = this.propertyDescriptor;\n\n    var otherAttrs,\n        properties;\n\n    var isGeneric = elementDescriptor.isGeneric;\n\n    if (isGeneric) {\n      otherAttrs = this.parseGeneric(element);\n    } else {\n      otherAttrs = this.parseNsAttributes(element);\n    }\n\n    if (propertyDescriptor) {\n      this.ns = this.nsPropertyTagName(propertyDescriptor);\n    } else {\n      this.ns = this.nsTagName(elementDescriptor);\n    }\n\n    // compute tag name\n    this.tagName = this.addTagName(this.ns);\n\n    if (!isGeneric) {\n      properties = getSerializableProperties(element);\n\n      this.parseAttributes(filterAttributes(properties));\n      this.parseContainments(filterContained(properties));\n    }\n\n    this.parseGenericAttributes(element, otherAttrs);\n\n    return this;\n  };\n\n  ElementSerializer.prototype.nsTagName = function(descriptor) {\n    var effectiveNs = this.logNamespaceUsed(descriptor.ns);\n    return getElementNs(effectiveNs, descriptor);\n  };\n\n  ElementSerializer.prototype.nsPropertyTagName = function(descriptor) {\n    var effectiveNs = this.logNamespaceUsed(descriptor.ns);\n    return getPropertyNs(effectiveNs, descriptor);\n  };\n\n  ElementSerializer.prototype.isLocalNs = function(ns) {\n    return ns.uri === this.ns.uri;\n  };\n\n  /**\n   * Get the actual ns attribute name for the given element.\n   *\n   * @param {Object} element\n   * @param {Boolean} [element.inherited=false]\n   *\n   * @return {Object} nsName\n   */\n  ElementSerializer.prototype.nsAttributeName = function(element) {\n\n    var ns;\n\n    if (isString(element)) {\n      ns = parseName(element);\n    } else {\n      ns = element.ns;\n    }\n\n    // return just local name for inherited attributes\n    if (element.inherited) {\n      return { localName: ns.localName };\n    }\n\n    // parse + log effective ns\n    var effectiveNs = this.logNamespaceUsed(ns);\n\n    // LOG ACTUAL namespace use\n    this.getNamespaces().logUsed(effectiveNs);\n\n    // strip prefix if same namespace like parent\n    if (this.isLocalNs(effectiveNs)) {\n      return { localName: ns.localName };\n    } else {\n      return assign({ localName: ns.localName }, effectiveNs);\n    }\n  };\n\n  ElementSerializer.prototype.parseGeneric = function(element) {\n\n    var self = this,\n        body = this.body;\n\n    var attributes = [];\n\n    forEach(element, function(val, key) {\n\n      var nonNsAttr;\n\n      if (key === \'$body\') {\n        body.push(new BodySerializer().build({ type: \'String\' }, val));\n      } else\n      if (key === \'$children\') {\n        forEach(val, function(child) {\n          body.push(new ElementSerializer(self).build(child));\n        });\n      } else\n      if (key.indexOf(\'$\') !== 0) {\n        nonNsAttr = self.parseNsAttribute(element, key, val);\n\n        if (nonNsAttr) {\n          attributes.push({ name: key, value: val });\n        }\n      }\n    });\n\n    return attributes;\n  };\n\n  ElementSerializer.prototype.parseNsAttribute = function(element, name, value) {\n    var model = element.$model;\n\n    var nameNs = parseName(name);\n\n    var ns;\n\n    // parse xmlns:foo="http://foo.bar"\n    if (nameNs.prefix === \'xmlns\') {\n      ns = { prefix: nameNs.localName, uri: value };\n    }\n\n    // parse xmlns="http://foo.bar"\n    if (!nameNs.prefix && nameNs.localName === \'xmlns\') {\n      ns = { uri: value };\n    }\n\n    if (!ns) {\n      return {\n        name: name,\n        value: value\n      };\n    }\n\n    if (model && model.getPackage(value)) {\n\n      // register well known namespace\n      this.logNamespace(ns, true, true);\n    } else {\n\n      // log custom namespace directly as used\n      var actualNs = this.logNamespaceUsed(ns, true);\n\n      this.getNamespaces().logUsed(actualNs);\n    }\n  };\n\n\n  /**\n   * Parse namespaces and return a list of left over generic attributes\n   *\n   * @param  {Object} element\n   * @return {Array<Object>}\n   */\n  ElementSerializer.prototype.parseNsAttributes = function(element, attrs) {\n    var self = this;\n\n    var genericAttrs = element.$attrs;\n\n    var attributes = [];\n\n    // parse namespace attributes first\n    // and log them. push non namespace attributes to a list\n    // and process them later\n    forEach(genericAttrs, function(value, name) {\n\n      var nonNsAttr = self.parseNsAttribute(element, name, value);\n\n      if (nonNsAttr) {\n        attributes.push(nonNsAttr);\n      }\n    });\n\n    return attributes;\n  };\n\n  ElementSerializer.prototype.parseGenericAttributes = function(element, attributes) {\n\n    var self = this;\n\n    forEach(attributes, function(attr) {\n\n      // do not serialize xsi:type attribute\n      // it is set manually based on the actual implementation type\n      if (attr.name === XSI_TYPE$1) {\n        return;\n      }\n\n      try {\n        self.addAttribute(self.nsAttributeName(attr.name), attr.value);\n      } catch (e) {\n        console.warn(\n          \'missing namespace information for \',\n          attr.name, \'=\', attr.value, \'on\', element,\n          e);\n      }\n    });\n  };\n\n  ElementSerializer.prototype.parseContainments = function(properties) {\n\n    var self = this,\n        body = this.body,\n        element = this.element;\n\n    forEach(properties, function(p) {\n      var value = element.get(p.name),\n          isReference = p.isReference,\n          isMany = p.isMany;\n\n      if (!isMany) {\n        value = [ value ];\n      }\n\n      if (p.isBody) {\n        body.push(new BodySerializer().build(p, value[0]));\n      } else\n      if (isSimple(p.type)) {\n        forEach(value, function(v) {\n          body.push(new ValueSerializer(self.addTagName(self.nsPropertyTagName(p))).build(p, v));\n        });\n      } else\n      if (isReference) {\n        forEach(value, function(v) {\n          body.push(new ReferenceSerializer(self.addTagName(self.nsPropertyTagName(p))).build(v));\n        });\n      } else {\n\n        // allow serialization via type\n        // rather than element name\n        var asType = serializeAsType(p),\n            asProperty = serializeAsProperty(p);\n\n        forEach(value, function(v) {\n          var serializer;\n\n          if (asType) {\n            serializer = new TypeSerializer(self, p);\n          } else\n          if (asProperty) {\n            serializer = new ElementSerializer(self, p);\n          } else {\n            serializer = new ElementSerializer(self);\n          }\n\n          body.push(serializer.build(v));\n        });\n      }\n    });\n  };\n\n  ElementSerializer.prototype.getNamespaces = function(local) {\n\n    var namespaces = this.namespaces,\n        parent = this.parent,\n        parentNamespaces;\n\n    if (!namespaces) {\n      parentNamespaces = parent && parent.getNamespaces();\n\n      if (local || !parentNamespaces) {\n        this.namespaces = namespaces = new Namespaces(parentNamespaces);\n      } else {\n        namespaces = parentNamespaces;\n      }\n    }\n\n    return namespaces;\n  };\n\n  ElementSerializer.prototype.logNamespace = function(ns, wellknown, local) {\n    var namespaces = this.getNamespaces(local);\n\n    var nsUri = ns.uri,\n        nsPrefix = ns.prefix;\n\n    var existing = namespaces.byUri(nsUri);\n\n    if (!existing || local) {\n      namespaces.add(ns, wellknown);\n    }\n\n    namespaces.mapPrefix(nsPrefix, nsUri);\n\n    return ns;\n  };\n\n  ElementSerializer.prototype.logNamespaceUsed = function(ns, local) {\n    var element = this.element,\n        model = element.$model,\n        namespaces = this.getNamespaces(local);\n\n    // ns may be\n    //\n    //   * prefix only\n    //   * prefix:uri\n    //   * localName only\n\n    var prefix = ns.prefix,\n        uri = ns.uri,\n        newPrefix, idx,\n        wellknownUri;\n\n    // handle anonymous namespaces (elementForm=unqualified), cf. #23\n    if (!prefix && !uri) {\n      return { localName: ns.localName };\n    }\n\n    wellknownUri = DEFAULT_NS_MAP[prefix] || model && (model.getPackage(prefix) || {}).uri;\n\n    uri = uri || wellknownUri || namespaces.uriByPrefix(prefix);\n\n    if (!uri) {\n      throw new Error(\'no namespace uri given for prefix <\' + prefix + \'>\');\n    }\n\n    ns = namespaces.byUri(uri);\n\n    if (!ns) {\n      newPrefix = prefix;\n      idx = 1;\n\n      // find a prefix that is not mapped yet\n      while (namespaces.uriByPrefix(newPrefix)) {\n        newPrefix = prefix + \'_\' + idx++;\n      }\n\n      ns = this.logNamespace({ prefix: newPrefix, uri: uri }, wellknownUri === uri);\n    }\n\n    if (prefix) {\n      namespaces.mapPrefix(prefix, uri);\n    }\n\n    return ns;\n  };\n\n  ElementSerializer.prototype.parseAttributes = function(properties) {\n    var self = this,\n        element = this.element;\n\n    forEach(properties, function(p) {\n\n      var value = element.get(p.name);\n\n      if (p.isReference) {\n\n        if (!p.isMany) {\n          value = value.id;\n        }\n        else {\n          var values = [];\n          forEach(value, function(v) {\n            values.push(v.id);\n          });\n\n          // IDREFS is a whitespace-separated list of references.\n          value = values.join(\' \');\n        }\n\n      }\n\n      self.addAttribute(self.nsAttributeName(p), value);\n    });\n  };\n\n  ElementSerializer.prototype.addTagName = function(nsTagName) {\n    var actualNs = this.logNamespaceUsed(nsTagName);\n\n    this.getNamespaces().logUsed(actualNs);\n\n    return nsName(nsTagName);\n  };\n\n  ElementSerializer.prototype.addAttribute = function(name, value) {\n    var attrs = this.attrs;\n\n    if (isString(value)) {\n      value = escapeAttr(value);\n    }\n\n    attrs.push({ name: name, value: value });\n  };\n\n  ElementSerializer.prototype.serializeAttributes = function(writer) {\n    var attrs = this.attrs,\n        namespaces = this.namespaces;\n\n    if (namespaces) {\n      attrs = getNsAttrs(namespaces).concat(attrs);\n    }\n\n    forEach(attrs, function(a) {\n      writer\n        .append(\' \')\n        .append(nsName(a.name)).append(\'="\').append(a.value).append(\'"\');\n    });\n  };\n\n  ElementSerializer.prototype.serializeTo = function(writer) {\n    var firstBody = this.body[0],\n        indent = firstBody && firstBody.constructor !== BodySerializer;\n\n    writer\n      .appendIndent()\n      .append(\'<\' + this.tagName);\n\n    this.serializeAttributes(writer);\n\n    writer.append(firstBody ? \'>\' : \' />\');\n\n    if (firstBody) {\n\n      if (indent) {\n        writer\n          .appendNewLine()\n          .indent();\n      }\n\n      forEach(this.body, function(b) {\n        b.serializeTo(writer);\n      });\n\n      if (indent) {\n        writer\n          .unindent()\n          .appendIndent();\n      }\n\n      writer.append(\'</\' + this.tagName + \'>\');\n    }\n\n    writer.appendNewLine();\n  };\n\n  /**\n   * A serializer for types that handles serialization of data types\n   */\n  function TypeSerializer(parent, propertyDescriptor) {\n    ElementSerializer.call(this, parent, propertyDescriptor);\n  }\n\n  inherits(TypeSerializer, ElementSerializer);\n\n  TypeSerializer.prototype.parseNsAttributes = function(element) {\n\n    // extracted attributes\n    var attributes = ElementSerializer.prototype.parseNsAttributes.call(this, element);\n\n    var descriptor = element.$descriptor;\n\n    // only serialize xsi:type if necessary\n    if (descriptor.name === this.propertyDescriptor.type) {\n      return attributes;\n    }\n\n    var typeNs = this.typeNs = this.nsTagName(descriptor);\n    this.getNamespaces().logUsed(this.typeNs);\n\n    // add xsi:type attribute to represent the elements\n    // actual type\n\n    var pkg = element.$model.getPackage(typeNs.uri),\n        typePrefix = (pkg.xml && pkg.xml.typePrefix) || \'\';\n\n    this.addAttribute(\n      this.nsAttributeName(XSI_TYPE$1),\n      (typeNs.prefix ? typeNs.prefix + \':\' : \'\') + typePrefix + descriptor.ns.localName\n    );\n\n    return attributes;\n  };\n\n  TypeSerializer.prototype.isLocalNs = function(ns) {\n    return ns.uri === (this.typeNs || this.ns).uri;\n  };\n\n  function SavingWriter() {\n    this.value = \'\';\n\n    this.write = function(str) {\n      this.value += str;\n    };\n  }\n\n  function FormatingWriter(out, format) {\n\n    var indent = [\'\'];\n\n    this.append = function(str) {\n      out.write(str);\n\n      return this;\n    };\n\n    this.appendNewLine = function() {\n      if (format) {\n        out.write(\'\\n\');\n      }\n\n      return this;\n    };\n\n    this.appendIndent = function() {\n      if (format) {\n        out.write(indent.join(\'  \'));\n      }\n\n      return this;\n    };\n\n    this.indent = function() {\n      indent.push(\'\');\n      return this;\n    };\n\n    this.unindent = function() {\n      indent.pop();\n      return this;\n    };\n  }\n\n  /**\n   * A writer for meta-model backed document trees\n   *\n   * @param {Object} options output options to pass into the writer\n   */\n  function Writer(options) {\n\n    options = assign({ format: false, preamble: true }, options || {});\n\n    function toXML(tree, writer) {\n      var internalWriter = writer || new SavingWriter();\n      var formatingWriter = new FormatingWriter(internalWriter, options.format);\n\n      if (options.preamble) {\n        formatingWriter.append(XML_PREAMBLE);\n      }\n\n      new ElementSerializer().build(tree).serializeTo(formatingWriter);\n\n      if (!writer) {\n        return internalWriter.value;\n      }\n    }\n\n    return {\n      toXML: toXML\n    };\n  }\n\n  /**\n   * A sub class of {@link Moddle} with support for import and export of BPMN 2.0 xml files.\n   *\n   * @class BpmnModdle\n   * @extends Moddle\n   *\n   * @param {Object|Array} packages to use for instantiating the model\n   * @param {Object} [options] additional options to pass over\n   */\n  function BpmnModdle(packages, options) {\n    Moddle.call(this, packages, options);\n  }\n\n  BpmnModdle.prototype = Object.create(Moddle.prototype);\n\n  /**\n   * The fromXML result.\n   *\n   * @typedef {Object} ParseResult\n   *\n   * @property {ModdleElement} rootElement\n   * @property {Array<Object>} references\n   * @property {Array<Error>} warnings\n   * @property {Object} elementsById - a mapping containing each ID -> ModdleElement\n   */\n\n  /**\n   * The fromXML error.\n   *\n   * @typedef {Error} ParseError\n   *\n   * @property {Array<Error>} warnings\n   */\n\n  /**\n   * Instantiates a BPMN model tree from a given xml string.\n   *\n   * @param {String}   xmlStr\n   * @param {String}   [typeName=\'bpmn:Definitions\'] name of the root element\n   * @param {Object}   [options]  options to pass to the underlying reader\n   *\n   * @returns {Promise<ParseResult, ParseError>}\n   */\n  BpmnModdle.prototype.fromXML = function(xmlStr, typeName, options) {\n\n    if (!isString(typeName)) {\n      options = typeName;\n      typeName = \'bpmn:Definitions\';\n    }\n\n    var reader = new Reader(assign({ model: this, lax: true }, options));\n    var rootHandler = reader.handler(typeName);\n\n    return reader.fromXML(xmlStr, rootHandler);\n  };\n\n\n  /**\n   * The toXML result.\n   *\n   * @typedef {Object} SerializationResult\n   *\n   * @property {String} xml\n   */\n\n  /**\n   * Serializes a BPMN 2.0 object tree to XML.\n   *\n   * @param {String}   element    the root element, typically an instance of `bpmn:Definitions`\n   * @param {Object}   [options]  to pass to the underlying writer\n   *\n   * @returns {Promise<SerializationResult, Error>}\n   */\n  BpmnModdle.prototype.toXML = function(element, options) {\n\n    var writer = new Writer(options);\n\n    return new Promise(function(resolve, reject) {\n      try {\n        var result = writer.toXML(element);\n\n        return resolve({\n          xml: result\n        });\n      } catch (err) {\n        return reject(err);\n      }\n    });\n  };\n\n  var name = "BPMN20";\n  var uri = "http://www.omg.org/spec/BPMN/20100524/MODEL";\n  var prefix = "bpmn";\n  var associations = [\n  ];\n  var types = [\n  \t{\n  \t\tname: "Interface",\n  \t\tsuperClass: [\n  \t\t\t"RootElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "operations",\n  \t\t\t\ttype: "Operation",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "implementationRef",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Operation",\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "inMessageRef",\n  \t\t\t\ttype: "Message",\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "outMessageRef",\n  \t\t\t\ttype: "Message",\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "errorRef",\n  \t\t\t\ttype: "Error",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "implementationRef",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "EndPoint",\n  \t\tsuperClass: [\n  \t\t\t"RootElement"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Auditing",\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "GlobalTask",\n  \t\tsuperClass: [\n  \t\t\t"CallableElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "resources",\n  \t\t\t\ttype: "ResourceRole",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Monitoring",\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Performer",\n  \t\tsuperClass: [\n  \t\t\t"ResourceRole"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Process",\n  \t\tsuperClass: [\n  \t\t\t"FlowElementsContainer",\n  \t\t\t"CallableElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "processType",\n  \t\t\t\ttype: "ProcessType",\n  \t\t\t\tisAttr: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "isClosed",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "Boolean"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "auditing",\n  \t\t\t\ttype: "Auditing"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "monitoring",\n  \t\t\t\ttype: "Monitoring"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "properties",\n  \t\t\t\ttype: "Property",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "laneSets",\n  \t\t\t\tisMany: true,\n  \t\t\t\treplaces: "FlowElementsContainer#laneSets",\n  \t\t\t\ttype: "LaneSet"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "flowElements",\n  \t\t\t\tisMany: true,\n  \t\t\t\treplaces: "FlowElementsContainer#flowElements",\n  \t\t\t\ttype: "FlowElement"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "artifacts",\n  \t\t\t\ttype: "Artifact",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "resources",\n  \t\t\t\ttype: "ResourceRole",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "correlationSubscriptions",\n  \t\t\t\ttype: "CorrelationSubscription",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "supports",\n  \t\t\t\ttype: "Process",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "definitionalCollaborationRef",\n  \t\t\t\ttype: "Collaboration",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "isExecutable",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "Boolean"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "LaneSet",\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "lanes",\n  \t\t\t\ttype: "Lane",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Lane",\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "partitionElementRef",\n  \t\t\t\ttype: "BaseElement",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "partitionElement",\n  \t\t\t\ttype: "BaseElement"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "flowNodeRef",\n  \t\t\t\ttype: "FlowNode",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "childLaneSet",\n  \t\t\t\ttype: "LaneSet",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: "xsi:type"\n  \t\t\t\t}\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "GlobalManualTask",\n  \t\tsuperClass: [\n  \t\t\t"GlobalTask"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "ManualTask",\n  \t\tsuperClass: [\n  \t\t\t"Task"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "UserTask",\n  \t\tsuperClass: [\n  \t\t\t"Task"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "renderings",\n  \t\t\t\ttype: "Rendering",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "implementation",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Rendering",\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "HumanPerformer",\n  \t\tsuperClass: [\n  \t\t\t"Performer"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "PotentialOwner",\n  \t\tsuperClass: [\n  \t\t\t"HumanPerformer"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "GlobalUserTask",\n  \t\tsuperClass: [\n  \t\t\t"GlobalTask"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "implementation",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "renderings",\n  \t\t\t\ttype: "Rendering",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Gateway",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t"FlowNode"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "gatewayDirection",\n  \t\t\t\ttype: "GatewayDirection",\n  \t\t\t\t"default": "Unspecified",\n  \t\t\t\tisAttr: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "EventBasedGateway",\n  \t\tsuperClass: [\n  \t\t\t"Gateway"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "instantiate",\n  \t\t\t\t"default": false,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "Boolean"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "eventGatewayType",\n  \t\t\t\ttype: "EventBasedGatewayType",\n  \t\t\t\tisAttr: true,\n  \t\t\t\t"default": "Exclusive"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "ComplexGateway",\n  \t\tsuperClass: [\n  \t\t\t"Gateway"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "activationCondition",\n  \t\t\t\ttype: "Expression",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: "xsi:type"\n  \t\t\t\t}\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "default",\n  \t\t\t\ttype: "SequenceFlow",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "ExclusiveGateway",\n  \t\tsuperClass: [\n  \t\t\t"Gateway"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "default",\n  \t\t\t\ttype: "SequenceFlow",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "InclusiveGateway",\n  \t\tsuperClass: [\n  \t\t\t"Gateway"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "default",\n  \t\t\t\ttype: "SequenceFlow",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "ParallelGateway",\n  \t\tsuperClass: [\n  \t\t\t"Gateway"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "RootElement",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Relationship",\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "type",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "direction",\n  \t\t\t\ttype: "RelationshipDirection",\n  \t\t\t\tisAttr: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "source",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true,\n  \t\t\t\ttype: "Element"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "target",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true,\n  \t\t\t\ttype: "Element"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "BaseElement",\n  \t\tisAbstract: true,\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "id",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String",\n  \t\t\t\tisId: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "documentation",\n  \t\t\t\ttype: "Documentation",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "extensionDefinitions",\n  \t\t\t\ttype: "ExtensionDefinition",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "extensionElements",\n  \t\t\t\ttype: "ExtensionElements"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Extension",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "mustUnderstand",\n  \t\t\t\t"default": false,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "Boolean"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "definition",\n  \t\t\t\ttype: "ExtensionDefinition",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "ExtensionDefinition",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "extensionAttributeDefinitions",\n  \t\t\t\ttype: "ExtensionAttributeDefinition",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "ExtensionAttributeDefinition",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "type",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "isReference",\n  \t\t\t\t"default": false,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "Boolean"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "extensionDefinition",\n  \t\t\t\ttype: "ExtensionDefinition",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "ExtensionElements",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "valueRef",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true,\n  \t\t\t\ttype: "Element"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "values",\n  \t\t\t\ttype: "Element",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "extensionAttributeDefinition",\n  \t\t\t\ttype: "ExtensionAttributeDefinition",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Documentation",\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "text",\n  \t\t\t\ttype: "String",\n  \t\t\t\tisBody: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "textFormat",\n  \t\t\t\t"default": "text/plain",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Event",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t"FlowNode",\n  \t\t\t"InteractionNode"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "properties",\n  \t\t\t\ttype: "Property",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "IntermediateCatchEvent",\n  \t\tsuperClass: [\n  \t\t\t"CatchEvent"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "IntermediateThrowEvent",\n  \t\tsuperClass: [\n  \t\t\t"ThrowEvent"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "EndEvent",\n  \t\tsuperClass: [\n  \t\t\t"ThrowEvent"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "StartEvent",\n  \t\tsuperClass: [\n  \t\t\t"CatchEvent"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "isInterrupting",\n  \t\t\t\t"default": true,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "Boolean"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "ThrowEvent",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t"Event"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "dataInputs",\n  \t\t\t\ttype: "DataInput",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "dataInputAssociations",\n  \t\t\t\ttype: "DataInputAssociation",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "inputSet",\n  \t\t\t\ttype: "InputSet"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "eventDefinitions",\n  \t\t\t\ttype: "EventDefinition",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "eventDefinitionRef",\n  \t\t\t\ttype: "EventDefinition",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "CatchEvent",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t"Event"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "parallelMultiple",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "Boolean",\n  \t\t\t\t"default": false\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "dataOutputs",\n  \t\t\t\ttype: "DataOutput",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "dataOutputAssociations",\n  \t\t\t\ttype: "DataOutputAssociation",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "outputSet",\n  \t\t\t\ttype: "OutputSet"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "eventDefinitions",\n  \t\t\t\ttype: "EventDefinition",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "eventDefinitionRef",\n  \t\t\t\ttype: "EventDefinition",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "BoundaryEvent",\n  \t\tsuperClass: [\n  \t\t\t"CatchEvent"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "cancelActivity",\n  \t\t\t\t"default": true,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "Boolean"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "attachedToRef",\n  \t\t\t\ttype: "Activity",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "EventDefinition",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t"RootElement"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "CancelEventDefinition",\n  \t\tsuperClass: [\n  \t\t\t"EventDefinition"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "ErrorEventDefinition",\n  \t\tsuperClass: [\n  \t\t\t"EventDefinition"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "errorRef",\n  \t\t\t\ttype: "Error",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "TerminateEventDefinition",\n  \t\tsuperClass: [\n  \t\t\t"EventDefinition"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "EscalationEventDefinition",\n  \t\tsuperClass: [\n  \t\t\t"EventDefinition"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "escalationRef",\n  \t\t\t\ttype: "Escalation",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Escalation",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "structureRef",\n  \t\t\t\ttype: "ItemDefinition",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "escalationCode",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t}\n  \t\t],\n  \t\tsuperClass: [\n  \t\t\t"RootElement"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "CompensateEventDefinition",\n  \t\tsuperClass: [\n  \t\t\t"EventDefinition"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "waitForCompletion",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "Boolean",\n  \t\t\t\t"default": true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "activityRef",\n  \t\t\t\ttype: "Activity",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "TimerEventDefinition",\n  \t\tsuperClass: [\n  \t\t\t"EventDefinition"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "timeDate",\n  \t\t\t\ttype: "Expression",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: "xsi:type"\n  \t\t\t\t}\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "timeCycle",\n  \t\t\t\ttype: "Expression",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: "xsi:type"\n  \t\t\t\t}\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "timeDuration",\n  \t\t\t\ttype: "Expression",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: "xsi:type"\n  \t\t\t\t}\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "LinkEventDefinition",\n  \t\tsuperClass: [\n  \t\t\t"EventDefinition"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "target",\n  \t\t\t\ttype: "LinkEventDefinition",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "source",\n  \t\t\t\ttype: "LinkEventDefinition",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "MessageEventDefinition",\n  \t\tsuperClass: [\n  \t\t\t"EventDefinition"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "messageRef",\n  \t\t\t\ttype: "Message",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "operationRef",\n  \t\t\t\ttype: "Operation",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "ConditionalEventDefinition",\n  \t\tsuperClass: [\n  \t\t\t"EventDefinition"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "condition",\n  \t\t\t\ttype: "Expression",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: "xsi:type"\n  \t\t\t\t}\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "SignalEventDefinition",\n  \t\tsuperClass: [\n  \t\t\t"EventDefinition"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "signalRef",\n  \t\t\t\ttype: "Signal",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Signal",\n  \t\tsuperClass: [\n  \t\t\t"RootElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "structureRef",\n  \t\t\t\ttype: "ItemDefinition",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "ImplicitThrowEvent",\n  \t\tsuperClass: [\n  \t\t\t"ThrowEvent"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "DataState",\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "ItemAwareElement",\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "itemSubjectRef",\n  \t\t\t\ttype: "ItemDefinition",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "dataState",\n  \t\t\t\ttype: "DataState"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "DataAssociation",\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "sourceRef",\n  \t\t\t\ttype: "ItemAwareElement",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "targetRef",\n  \t\t\t\ttype: "ItemAwareElement",\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "transformation",\n  \t\t\t\ttype: "FormalExpression",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: "property"\n  \t\t\t\t}\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "assignment",\n  \t\t\t\ttype: "Assignment",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "DataInput",\n  \t\tsuperClass: [\n  \t\t\t"ItemAwareElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "isCollection",\n  \t\t\t\t"default": false,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "Boolean"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "inputSetRef",\n  \t\t\t\ttype: "InputSet",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisVirtual: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "inputSetWithOptional",\n  \t\t\t\ttype: "InputSet",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisVirtual: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "inputSetWithWhileExecuting",\n  \t\t\t\ttype: "InputSet",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisVirtual: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "DataOutput",\n  \t\tsuperClass: [\n  \t\t\t"ItemAwareElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "isCollection",\n  \t\t\t\t"default": false,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "Boolean"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "outputSetRef",\n  \t\t\t\ttype: "OutputSet",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisVirtual: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "outputSetWithOptional",\n  \t\t\t\ttype: "OutputSet",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisVirtual: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "outputSetWithWhileExecuting",\n  \t\t\t\ttype: "OutputSet",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisVirtual: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "InputSet",\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "dataInputRefs",\n  \t\t\t\ttype: "DataInput",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "optionalInputRefs",\n  \t\t\t\ttype: "DataInput",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "whileExecutingInputRefs",\n  \t\t\t\ttype: "DataInput",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "outputSetRefs",\n  \t\t\t\ttype: "OutputSet",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "OutputSet",\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "dataOutputRefs",\n  \t\t\t\ttype: "DataOutput",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "inputSetRefs",\n  \t\t\t\ttype: "InputSet",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "optionalOutputRefs",\n  \t\t\t\ttype: "DataOutput",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "whileExecutingOutputRefs",\n  \t\t\t\ttype: "DataOutput",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Property",\n  \t\tsuperClass: [\n  \t\t\t"ItemAwareElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "DataInputAssociation",\n  \t\tsuperClass: [\n  \t\t\t"DataAssociation"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "DataOutputAssociation",\n  \t\tsuperClass: [\n  \t\t\t"DataAssociation"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "InputOutputSpecification",\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "dataInputs",\n  \t\t\t\ttype: "DataInput",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "dataOutputs",\n  \t\t\t\ttype: "DataOutput",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "inputSets",\n  \t\t\t\ttype: "InputSet",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "outputSets",\n  \t\t\t\ttype: "OutputSet",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "DataObject",\n  \t\tsuperClass: [\n  \t\t\t"FlowElement",\n  \t\t\t"ItemAwareElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "isCollection",\n  \t\t\t\t"default": false,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "Boolean"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "InputOutputBinding",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "inputDataRef",\n  \t\t\t\ttype: "InputSet",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "outputDataRef",\n  \t\t\t\ttype: "OutputSet",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "operationRef",\n  \t\t\t\ttype: "Operation",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Assignment",\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "from",\n  \t\t\t\ttype: "Expression",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: "xsi:type"\n  \t\t\t\t}\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "to",\n  \t\t\t\ttype: "Expression",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: "xsi:type"\n  \t\t\t\t}\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "DataStore",\n  \t\tsuperClass: [\n  \t\t\t"RootElement",\n  \t\t\t"ItemAwareElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "capacity",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "Integer"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "isUnlimited",\n  \t\t\t\t"default": true,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "Boolean"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "DataStoreReference",\n  \t\tsuperClass: [\n  \t\t\t"ItemAwareElement",\n  \t\t\t"FlowElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "dataStoreRef",\n  \t\t\t\ttype: "DataStore",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "DataObjectReference",\n  \t\tsuperClass: [\n  \t\t\t"ItemAwareElement",\n  \t\t\t"FlowElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "dataObjectRef",\n  \t\t\t\ttype: "DataObject",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "ConversationLink",\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "sourceRef",\n  \t\t\t\ttype: "InteractionNode",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "targetRef",\n  \t\t\t\ttype: "InteractionNode",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "ConversationAssociation",\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "innerConversationNodeRef",\n  \t\t\t\ttype: "ConversationNode",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "outerConversationNodeRef",\n  \t\t\t\ttype: "ConversationNode",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "CallConversation",\n  \t\tsuperClass: [\n  \t\t\t"ConversationNode"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "calledCollaborationRef",\n  \t\t\t\ttype: "Collaboration",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "participantAssociations",\n  \t\t\t\ttype: "ParticipantAssociation",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Conversation",\n  \t\tsuperClass: [\n  \t\t\t"ConversationNode"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "SubConversation",\n  \t\tsuperClass: [\n  \t\t\t"ConversationNode"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "conversationNodes",\n  \t\t\t\ttype: "ConversationNode",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "ConversationNode",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t"InteractionNode",\n  \t\t\t"BaseElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "participantRef",\n  \t\t\t\ttype: "Participant",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "messageFlowRefs",\n  \t\t\t\ttype: "MessageFlow",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "correlationKeys",\n  \t\t\t\ttype: "CorrelationKey",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "GlobalConversation",\n  \t\tsuperClass: [\n  \t\t\t"Collaboration"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "PartnerEntity",\n  \t\tsuperClass: [\n  \t\t\t"RootElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "participantRef",\n  \t\t\t\ttype: "Participant",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "PartnerRole",\n  \t\tsuperClass: [\n  \t\t\t"RootElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "participantRef",\n  \t\t\t\ttype: "Participant",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "CorrelationProperty",\n  \t\tsuperClass: [\n  \t\t\t"RootElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "correlationPropertyRetrievalExpression",\n  \t\t\t\ttype: "CorrelationPropertyRetrievalExpression",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "type",\n  \t\t\t\ttype: "ItemDefinition",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Error",\n  \t\tsuperClass: [\n  \t\t\t"RootElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "structureRef",\n  \t\t\t\ttype: "ItemDefinition",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "errorCode",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "CorrelationKey",\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "correlationPropertyRef",\n  \t\t\t\ttype: "CorrelationProperty",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Expression",\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t],\n  \t\tisAbstract: false,\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "body",\n  \t\t\t\tisBody: true,\n  \t\t\t\ttype: "String"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "FormalExpression",\n  \t\tsuperClass: [\n  \t\t\t"Expression"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "language",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "evaluatesToTypeRef",\n  \t\t\t\ttype: "ItemDefinition",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Message",\n  \t\tsuperClass: [\n  \t\t\t"RootElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "itemRef",\n  \t\t\t\ttype: "ItemDefinition",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "ItemDefinition",\n  \t\tsuperClass: [\n  \t\t\t"RootElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "itemKind",\n  \t\t\t\ttype: "ItemKind",\n  \t\t\t\tisAttr: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "structureRef",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "isCollection",\n  \t\t\t\t"default": false,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "Boolean"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "import",\n  \t\t\t\ttype: "Import",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "FlowElement",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "auditing",\n  \t\t\t\ttype: "Auditing"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "monitoring",\n  \t\t\t\ttype: "Monitoring"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "categoryValueRef",\n  \t\t\t\ttype: "CategoryValue",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "SequenceFlow",\n  \t\tsuperClass: [\n  \t\t\t"FlowElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "isImmediate",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "Boolean"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "conditionExpression",\n  \t\t\t\ttype: "Expression",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: "xsi:type"\n  \t\t\t\t}\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "sourceRef",\n  \t\t\t\ttype: "FlowNode",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "targetRef",\n  \t\t\t\ttype: "FlowNode",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "FlowElementsContainer",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "laneSets",\n  \t\t\t\ttype: "LaneSet",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "flowElements",\n  \t\t\t\ttype: "FlowElement",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "CallableElement",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t"RootElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "ioSpecification",\n  \t\t\t\ttype: "InputOutputSpecification",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: "property"\n  \t\t\t\t}\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "supportedInterfaceRef",\n  \t\t\t\ttype: "Interface",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "ioBinding",\n  \t\t\t\ttype: "InputOutputBinding",\n  \t\t\t\tisMany: true,\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: "property"\n  \t\t\t\t}\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "FlowNode",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t"FlowElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "incoming",\n  \t\t\t\ttype: "SequenceFlow",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "outgoing",\n  \t\t\t\ttype: "SequenceFlow",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "lanes",\n  \t\t\t\ttype: "Lane",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisVirtual: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "CorrelationPropertyRetrievalExpression",\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "messagePath",\n  \t\t\t\ttype: "FormalExpression"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "messageRef",\n  \t\t\t\ttype: "Message",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "CorrelationPropertyBinding",\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "dataPath",\n  \t\t\t\ttype: "FormalExpression"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "correlationPropertyRef",\n  \t\t\t\ttype: "CorrelationProperty",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Resource",\n  \t\tsuperClass: [\n  \t\t\t"RootElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "resourceParameters",\n  \t\t\t\ttype: "ResourceParameter",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "ResourceParameter",\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "isRequired",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "Boolean"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "type",\n  \t\t\t\ttype: "ItemDefinition",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "CorrelationSubscription",\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "correlationKeyRef",\n  \t\t\t\ttype: "CorrelationKey",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "correlationPropertyBinding",\n  \t\t\t\ttype: "CorrelationPropertyBinding",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "MessageFlow",\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "sourceRef",\n  \t\t\t\ttype: "InteractionNode",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "targetRef",\n  \t\t\t\ttype: "InteractionNode",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "messageRef",\n  \t\t\t\ttype: "Message",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "MessageFlowAssociation",\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "innerMessageFlowRef",\n  \t\t\t\ttype: "MessageFlow",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "outerMessageFlowRef",\n  \t\t\t\ttype: "MessageFlow",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "InteractionNode",\n  \t\tisAbstract: true,\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "incomingConversationLinks",\n  \t\t\t\ttype: "ConversationLink",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisVirtual: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "outgoingConversationLinks",\n  \t\t\t\ttype: "ConversationLink",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisVirtual: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Participant",\n  \t\tsuperClass: [\n  \t\t\t"InteractionNode",\n  \t\t\t"BaseElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "interfaceRef",\n  \t\t\t\ttype: "Interface",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "participantMultiplicity",\n  \t\t\t\ttype: "ParticipantMultiplicity"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "endPointRefs",\n  \t\t\t\ttype: "EndPoint",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "processRef",\n  \t\t\t\ttype: "Process",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "ParticipantAssociation",\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "innerParticipantRef",\n  \t\t\t\ttype: "Participant",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "outerParticipantRef",\n  \t\t\t\ttype: "Participant",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "ParticipantMultiplicity",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "minimum",\n  \t\t\t\t"default": 0,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "Integer"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "maximum",\n  \t\t\t\t"default": 1,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "Integer"\n  \t\t\t}\n  \t\t],\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Collaboration",\n  \t\tsuperClass: [\n  \t\t\t"RootElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "isClosed",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "Boolean"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "participants",\n  \t\t\t\ttype: "Participant",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "messageFlows",\n  \t\t\t\ttype: "MessageFlow",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "artifacts",\n  \t\t\t\ttype: "Artifact",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "conversations",\n  \t\t\t\ttype: "ConversationNode",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "conversationAssociations",\n  \t\t\t\ttype: "ConversationAssociation"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "participantAssociations",\n  \t\t\t\ttype: "ParticipantAssociation",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "messageFlowAssociations",\n  \t\t\t\ttype: "MessageFlowAssociation",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "correlationKeys",\n  \t\t\t\ttype: "CorrelationKey",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "choreographyRef",\n  \t\t\t\ttype: "Choreography",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "conversationLinks",\n  \t\t\t\ttype: "ConversationLink",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "ChoreographyActivity",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t"FlowNode"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "participantRef",\n  \t\t\t\ttype: "Participant",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "initiatingParticipantRef",\n  \t\t\t\ttype: "Participant",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "correlationKeys",\n  \t\t\t\ttype: "CorrelationKey",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "loopType",\n  \t\t\t\ttype: "ChoreographyLoopType",\n  \t\t\t\t"default": "None",\n  \t\t\t\tisAttr: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "CallChoreography",\n  \t\tsuperClass: [\n  \t\t\t"ChoreographyActivity"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "calledChoreographyRef",\n  \t\t\t\ttype: "Choreography",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "participantAssociations",\n  \t\t\t\ttype: "ParticipantAssociation",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "SubChoreography",\n  \t\tsuperClass: [\n  \t\t\t"ChoreographyActivity",\n  \t\t\t"FlowElementsContainer"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "artifacts",\n  \t\t\t\ttype: "Artifact",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "ChoreographyTask",\n  \t\tsuperClass: [\n  \t\t\t"ChoreographyActivity"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "messageFlowRef",\n  \t\t\t\ttype: "MessageFlow",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Choreography",\n  \t\tsuperClass: [\n  \t\t\t"Collaboration",\n  \t\t\t"FlowElementsContainer"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "GlobalChoreographyTask",\n  \t\tsuperClass: [\n  \t\t\t"Choreography"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "initiatingParticipantRef",\n  \t\t\t\ttype: "Participant",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "TextAnnotation",\n  \t\tsuperClass: [\n  \t\t\t"Artifact"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "text",\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "textFormat",\n  \t\t\t\t"default": "text/plain",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Group",\n  \t\tsuperClass: [\n  \t\t\t"Artifact"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "categoryValueRef",\n  \t\t\t\ttype: "CategoryValue",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Association",\n  \t\tsuperClass: [\n  \t\t\t"Artifact"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "associationDirection",\n  \t\t\t\ttype: "AssociationDirection",\n  \t\t\t\tisAttr: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "sourceRef",\n  \t\t\t\ttype: "BaseElement",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "targetRef",\n  \t\t\t\ttype: "BaseElement",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Category",\n  \t\tsuperClass: [\n  \t\t\t"RootElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "categoryValue",\n  \t\t\t\ttype: "CategoryValue",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Artifact",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "CategoryValue",\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "categorizedFlowElements",\n  \t\t\t\ttype: "FlowElement",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisVirtual: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "value",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Activity",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t"FlowNode"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "isForCompensation",\n  \t\t\t\t"default": false,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "Boolean"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "default",\n  \t\t\t\ttype: "SequenceFlow",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "ioSpecification",\n  \t\t\t\ttype: "InputOutputSpecification",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: "property"\n  \t\t\t\t}\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "boundaryEventRefs",\n  \t\t\t\ttype: "BoundaryEvent",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "properties",\n  \t\t\t\ttype: "Property",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "dataInputAssociations",\n  \t\t\t\ttype: "DataInputAssociation",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "dataOutputAssociations",\n  \t\t\t\ttype: "DataOutputAssociation",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "startQuantity",\n  \t\t\t\t"default": 1,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "Integer"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "resources",\n  \t\t\t\ttype: "ResourceRole",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "completionQuantity",\n  \t\t\t\t"default": 1,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "Integer"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "loopCharacteristics",\n  \t\t\t\ttype: "LoopCharacteristics"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "ServiceTask",\n  \t\tsuperClass: [\n  \t\t\t"Task"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "implementation",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "operationRef",\n  \t\t\t\ttype: "Operation",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "SubProcess",\n  \t\tsuperClass: [\n  \t\t\t"Activity",\n  \t\t\t"FlowElementsContainer",\n  \t\t\t"InteractionNode"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "triggeredByEvent",\n  \t\t\t\t"default": false,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "Boolean"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "artifacts",\n  \t\t\t\ttype: "Artifact",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "LoopCharacteristics",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "MultiInstanceLoopCharacteristics",\n  \t\tsuperClass: [\n  \t\t\t"LoopCharacteristics"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "isSequential",\n  \t\t\t\t"default": false,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "Boolean"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "behavior",\n  \t\t\t\ttype: "MultiInstanceBehavior",\n  \t\t\t\t"default": "All",\n  \t\t\t\tisAttr: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "loopCardinality",\n  \t\t\t\ttype: "Expression",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: "xsi:type"\n  \t\t\t\t}\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "loopDataInputRef",\n  \t\t\t\ttype: "ItemAwareElement",\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "loopDataOutputRef",\n  \t\t\t\ttype: "ItemAwareElement",\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "inputDataItem",\n  \t\t\t\ttype: "DataInput",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: "property"\n  \t\t\t\t}\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "outputDataItem",\n  \t\t\t\ttype: "DataOutput",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: "property"\n  \t\t\t\t}\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "complexBehaviorDefinition",\n  \t\t\t\ttype: "ComplexBehaviorDefinition",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "completionCondition",\n  \t\t\t\ttype: "Expression",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: "xsi:type"\n  \t\t\t\t}\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "oneBehaviorEventRef",\n  \t\t\t\ttype: "EventDefinition",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "noneBehaviorEventRef",\n  \t\t\t\ttype: "EventDefinition",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "StandardLoopCharacteristics",\n  \t\tsuperClass: [\n  \t\t\t"LoopCharacteristics"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "testBefore",\n  \t\t\t\t"default": false,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "Boolean"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "loopCondition",\n  \t\t\t\ttype: "Expression",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: "xsi:type"\n  \t\t\t\t}\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "loopMaximum",\n  \t\t\t\ttype: "Integer",\n  \t\t\t\tisAttr: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "CallActivity",\n  \t\tsuperClass: [\n  \t\t\t"Activity",\n  \t\t\t"InteractionNode"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "calledElement",\n  \t\t\t\ttype: "String",\n  \t\t\t\tisAttr: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Task",\n  \t\tsuperClass: [\n  \t\t\t"Activity",\n  \t\t\t"InteractionNode"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "SendTask",\n  \t\tsuperClass: [\n  \t\t\t"Task"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "implementation",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "operationRef",\n  \t\t\t\ttype: "Operation",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "messageRef",\n  \t\t\t\ttype: "Message",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "ReceiveTask",\n  \t\tsuperClass: [\n  \t\t\t"Task"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "implementation",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "instantiate",\n  \t\t\t\t"default": false,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "Boolean"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "operationRef",\n  \t\t\t\ttype: "Operation",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "messageRef",\n  \t\t\t\ttype: "Message",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "ScriptTask",\n  \t\tsuperClass: [\n  \t\t\t"Task"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "scriptFormat",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "script",\n  \t\t\t\ttype: "String"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "BusinessRuleTask",\n  \t\tsuperClass: [\n  \t\t\t"Task"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "implementation",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "AdHocSubProcess",\n  \t\tsuperClass: [\n  \t\t\t"SubProcess"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "completionCondition",\n  \t\t\t\ttype: "Expression",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: "xsi:type"\n  \t\t\t\t}\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "ordering",\n  \t\t\t\ttype: "AdHocOrdering",\n  \t\t\t\tisAttr: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "cancelRemainingInstances",\n  \t\t\t\t"default": true,\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "Boolean"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Transaction",\n  \t\tsuperClass: [\n  \t\t\t"SubProcess"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "protocol",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "method",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "GlobalScriptTask",\n  \t\tsuperClass: [\n  \t\t\t"GlobalTask"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "scriptLanguage",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "script",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "GlobalBusinessRuleTask",\n  \t\tsuperClass: [\n  \t\t\t"GlobalTask"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "implementation",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "ComplexBehaviorDefinition",\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "condition",\n  \t\t\t\ttype: "FormalExpression"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "event",\n  \t\t\t\ttype: "ImplicitThrowEvent"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "ResourceRole",\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "resourceRef",\n  \t\t\t\ttype: "Resource",\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "resourceParameterBindings",\n  \t\t\t\ttype: "ResourceParameterBinding",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "resourceAssignmentExpression",\n  \t\t\t\ttype: "ResourceAssignmentExpression"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "ResourceParameterBinding",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "expression",\n  \t\t\t\ttype: "Expression",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: "xsi:type"\n  \t\t\t\t}\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "parameterRef",\n  \t\t\t\ttype: "ResourceParameter",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t],\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "ResourceAssignmentExpression",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "expression",\n  \t\t\t\ttype: "Expression",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: "xsi:type"\n  \t\t\t\t}\n  \t\t\t}\n  \t\t],\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Import",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "importType",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "location",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "namespace",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Definitions",\n  \t\tsuperClass: [\n  \t\t\t"BaseElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "targetNamespace",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "expressionLanguage",\n  \t\t\t\t"default": "http://www.w3.org/1999/XPath",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "typeLanguage",\n  \t\t\t\t"default": "http://www.w3.org/2001/XMLSchema",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "imports",\n  \t\t\t\ttype: "Import",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "extensions",\n  \t\t\t\ttype: "Extension",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "rootElements",\n  \t\t\t\ttype: "RootElement",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "diagrams",\n  \t\t\t\tisMany: true,\n  \t\t\t\ttype: "bpmndi:BPMNDiagram"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "exporter",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "relationships",\n  \t\t\t\ttype: "Relationship",\n  \t\t\t\tisMany: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "exporterVersion",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t}\n  \t\t]\n  \t}\n  ];\n  var enumerations = [\n  \t{\n  \t\tname: "ProcessType",\n  \t\tliteralValues: [\n  \t\t\t{\n  \t\t\t\tname: "None"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "Public"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "Private"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "GatewayDirection",\n  \t\tliteralValues: [\n  \t\t\t{\n  \t\t\t\tname: "Unspecified"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "Converging"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "Diverging"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "Mixed"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "EventBasedGatewayType",\n  \t\tliteralValues: [\n  \t\t\t{\n  \t\t\t\tname: "Parallel"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "Exclusive"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "RelationshipDirection",\n  \t\tliteralValues: [\n  \t\t\t{\n  \t\t\t\tname: "None"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "Forward"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "Backward"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "Both"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "ItemKind",\n  \t\tliteralValues: [\n  \t\t\t{\n  \t\t\t\tname: "Physical"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "Information"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "ChoreographyLoopType",\n  \t\tliteralValues: [\n  \t\t\t{\n  \t\t\t\tname: "None"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "Standard"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "MultiInstanceSequential"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "MultiInstanceParallel"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "AssociationDirection",\n  \t\tliteralValues: [\n  \t\t\t{\n  \t\t\t\tname: "None"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "One"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "Both"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "MultiInstanceBehavior",\n  \t\tliteralValues: [\n  \t\t\t{\n  \t\t\t\tname: "None"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "One"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "All"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "Complex"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "AdHocOrdering",\n  \t\tliteralValues: [\n  \t\t\t{\n  \t\t\t\tname: "Parallel"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "Sequential"\n  \t\t\t}\n  \t\t]\n  \t}\n  ];\n  var xml = {\n  \ttagAlias: "lowerCase",\n  \ttypePrefix: "t"\n  };\n  var BpmnPackage = {\n  \tname: name,\n  \turi: uri,\n  \tprefix: prefix,\n  \tassociations: associations,\n  \ttypes: types,\n  \tenumerations: enumerations,\n  \txml: xml\n  };\n\n  var name$1 = "BPMNDI";\n  var uri$1 = "http://www.omg.org/spec/BPMN/20100524/DI";\n  var prefix$1 = "bpmndi";\n  var types$1 = [\n  \t{\n  \t\tname: "BPMNDiagram",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "plane",\n  \t\t\t\ttype: "BPMNPlane",\n  \t\t\t\tredefines: "di:Diagram#rootElement"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "labelStyle",\n  \t\t\t\ttype: "BPMNLabelStyle",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t],\n  \t\tsuperClass: [\n  \t\t\t"di:Diagram"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "BPMNPlane",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "bpmnElement",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true,\n  \t\t\t\ttype: "bpmn:BaseElement",\n  \t\t\t\tredefines: "di:DiagramElement#modelElement"\n  \t\t\t}\n  \t\t],\n  \t\tsuperClass: [\n  \t\t\t"di:Plane"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "BPMNShape",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "bpmnElement",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true,\n  \t\t\t\ttype: "bpmn:BaseElement",\n  \t\t\t\tredefines: "di:DiagramElement#modelElement"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "isHorizontal",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "Boolean"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "isExpanded",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "Boolean"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "isMarkerVisible",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "Boolean"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "label",\n  \t\t\t\ttype: "BPMNLabel"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "isMessageVisible",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "Boolean"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "participantBandKind",\n  \t\t\t\ttype: "ParticipantBandKind",\n  \t\t\t\tisAttr: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "choreographyActivityShape",\n  \t\t\t\ttype: "BPMNShape",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true\n  \t\t\t}\n  \t\t],\n  \t\tsuperClass: [\n  \t\t\t"di:LabeledShape"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "BPMNEdge",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "label",\n  \t\t\t\ttype: "BPMNLabel"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "bpmnElement",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true,\n  \t\t\t\ttype: "bpmn:BaseElement",\n  \t\t\t\tredefines: "di:DiagramElement#modelElement"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "sourceElement",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true,\n  \t\t\t\ttype: "di:DiagramElement",\n  \t\t\t\tredefines: "di:Edge#source"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "targetElement",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true,\n  \t\t\t\ttype: "di:DiagramElement",\n  \t\t\t\tredefines: "di:Edge#target"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "messageVisibleKind",\n  \t\t\t\ttype: "MessageVisibleKind",\n  \t\t\t\tisAttr: true,\n  \t\t\t\t"default": "initiating"\n  \t\t\t}\n  \t\t],\n  \t\tsuperClass: [\n  \t\t\t"di:LabeledEdge"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "BPMNLabel",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "labelStyle",\n  \t\t\t\ttype: "BPMNLabelStyle",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisReference: true,\n  \t\t\t\tredefines: "di:DiagramElement#style"\n  \t\t\t}\n  \t\t],\n  \t\tsuperClass: [\n  \t\t\t"di:Label"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "BPMNLabelStyle",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "font",\n  \t\t\t\ttype: "dc:Font"\n  \t\t\t}\n  \t\t],\n  \t\tsuperClass: [\n  \t\t\t"di:Style"\n  \t\t]\n  \t}\n  ];\n  var enumerations$1 = [\n  \t{\n  \t\tname: "ParticipantBandKind",\n  \t\tliteralValues: [\n  \t\t\t{\n  \t\t\t\tname: "top_initiating"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "middle_initiating"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "bottom_initiating"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "top_non_initiating"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "middle_non_initiating"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "bottom_non_initiating"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "MessageVisibleKind",\n  \t\tliteralValues: [\n  \t\t\t{\n  \t\t\t\tname: "initiating"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "non_initiating"\n  \t\t\t}\n  \t\t]\n  \t}\n  ];\n  var associations$1 = [\n  ];\n  var BpmnDiPackage = {\n  \tname: name$1,\n  \turi: uri$1,\n  \tprefix: prefix$1,\n  \ttypes: types$1,\n  \tenumerations: enumerations$1,\n  \tassociations: associations$1\n  };\n\n  var name$2 = "DC";\n  var uri$2 = "http://www.omg.org/spec/DD/20100524/DC";\n  var prefix$2 = "dc";\n  var types$2 = [\n  \t{\n  \t\tname: "Boolean"\n  \t},\n  \t{\n  \t\tname: "Integer"\n  \t},\n  \t{\n  \t\tname: "Real"\n  \t},\n  \t{\n  \t\tname: "String"\n  \t},\n  \t{\n  \t\tname: "Font",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\ttype: "String",\n  \t\t\t\tisAttr: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "size",\n  \t\t\t\ttype: "Real",\n  \t\t\t\tisAttr: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "isBold",\n  \t\t\t\ttype: "Boolean",\n  \t\t\t\tisAttr: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "isItalic",\n  \t\t\t\ttype: "Boolean",\n  \t\t\t\tisAttr: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "isUnderline",\n  \t\t\t\ttype: "Boolean",\n  \t\t\t\tisAttr: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "isStrikeThrough",\n  \t\t\t\ttype: "Boolean",\n  \t\t\t\tisAttr: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Point",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "x",\n  \t\t\t\ttype: "Real",\n  \t\t\t\t"default": "0",\n  \t\t\t\tisAttr: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "y",\n  \t\t\t\ttype: "Real",\n  \t\t\t\t"default": "0",\n  \t\t\t\tisAttr: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Bounds",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "x",\n  \t\t\t\ttype: "Real",\n  \t\t\t\t"default": "0",\n  \t\t\t\tisAttr: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "y",\n  \t\t\t\ttype: "Real",\n  \t\t\t\t"default": "0",\n  \t\t\t\tisAttr: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "width",\n  \t\t\t\ttype: "Real",\n  \t\t\t\tisAttr: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "height",\n  \t\t\t\ttype: "Real",\n  \t\t\t\tisAttr: true\n  \t\t\t}\n  \t\t]\n  \t}\n  ];\n  var associations$2 = [\n  ];\n  var DcPackage = {\n  \tname: name$2,\n  \turi: uri$2,\n  \tprefix: prefix$2,\n  \ttypes: types$2,\n  \tassociations: associations$2\n  };\n\n  var name$3 = "DI";\n  var uri$3 = "http://www.omg.org/spec/DD/20100524/DI";\n  var prefix$3 = "di";\n  var types$3 = [\n  \t{\n  \t\tname: "DiagramElement",\n  \t\tisAbstract: true,\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "id",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisId: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "extension",\n  \t\t\t\ttype: "Extension"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "owningDiagram",\n  \t\t\t\ttype: "Diagram",\n  \t\t\t\tisReadOnly: true,\n  \t\t\t\tisVirtual: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "owningElement",\n  \t\t\t\ttype: "DiagramElement",\n  \t\t\t\tisReadOnly: true,\n  \t\t\t\tisVirtual: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "modelElement",\n  \t\t\t\tisReadOnly: true,\n  \t\t\t\tisVirtual: true,\n  \t\t\t\tisReference: true,\n  \t\t\t\ttype: "Element"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "style",\n  \t\t\t\ttype: "Style",\n  \t\t\t\tisReadOnly: true,\n  \t\t\t\tisVirtual: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "ownedElement",\n  \t\t\t\ttype: "DiagramElement",\n  \t\t\t\tisReadOnly: true,\n  \t\t\t\tisMany: true,\n  \t\t\t\tisVirtual: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Node",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t"DiagramElement"\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Edge",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t"DiagramElement"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "source",\n  \t\t\t\ttype: "DiagramElement",\n  \t\t\t\tisReadOnly: true,\n  \t\t\t\tisVirtual: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "target",\n  \t\t\t\ttype: "DiagramElement",\n  \t\t\t\tisReadOnly: true,\n  \t\t\t\tisVirtual: true,\n  \t\t\t\tisReference: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "waypoint",\n  \t\t\t\tisUnique: false,\n  \t\t\t\tisMany: true,\n  \t\t\t\ttype: "dc:Point",\n  \t\t\t\txml: {\n  \t\t\t\t\tserialize: "xsi:type"\n  \t\t\t\t}\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Diagram",\n  \t\tisAbstract: true,\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "id",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisId: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "rootElement",\n  \t\t\t\ttype: "DiagramElement",\n  \t\t\t\tisReadOnly: true,\n  \t\t\t\tisVirtual: true\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "name",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "documentation",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "resolution",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "Real"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "ownedStyle",\n  \t\t\t\ttype: "Style",\n  \t\t\t\tisReadOnly: true,\n  \t\t\t\tisMany: true,\n  \t\t\t\tisVirtual: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Shape",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t"Node"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "bounds",\n  \t\t\t\ttype: "dc:Bounds"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Plane",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t"Node"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "planeElement",\n  \t\t\t\ttype: "DiagramElement",\n  \t\t\t\tsubsettedProperty: "DiagramElement-ownedElement",\n  \t\t\t\tisMany: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "LabeledEdge",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t"Edge"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "ownedLabel",\n  \t\t\t\ttype: "Label",\n  \t\t\t\tisReadOnly: true,\n  \t\t\t\tsubsettedProperty: "DiagramElement-ownedElement",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisVirtual: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "LabeledShape",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t"Shape"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "ownedLabel",\n  \t\t\t\ttype: "Label",\n  \t\t\t\tisReadOnly: true,\n  \t\t\t\tsubsettedProperty: "DiagramElement-ownedElement",\n  \t\t\t\tisMany: true,\n  \t\t\t\tisVirtual: true\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Label",\n  \t\tisAbstract: true,\n  \t\tsuperClass: [\n  \t\t\t"Node"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "bounds",\n  \t\t\t\ttype: "dc:Bounds"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Style",\n  \t\tisAbstract: true,\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "id",\n  \t\t\t\tisAttr: true,\n  \t\t\t\tisId: true,\n  \t\t\t\ttype: "String"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "Extension",\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "values",\n  \t\t\t\tisMany: true,\n  \t\t\t\ttype: "Element"\n  \t\t\t}\n  \t\t]\n  \t}\n  ];\n  var associations$3 = [\n  ];\n  var xml$1 = {\n  \ttagAlias: "lowerCase"\n  };\n  var DiPackage = {\n  \tname: name$3,\n  \turi: uri$3,\n  \tprefix: prefix$3,\n  \ttypes: types$3,\n  \tassociations: associations$3,\n  \txml: xml$1\n  };\n\n  var name$4 = "bpmn.io colors for BPMN";\n  var uri$4 = "http://bpmn.io/schema/bpmn/biocolor/1.0";\n  var prefix$4 = "bioc";\n  var types$4 = [\n  \t{\n  \t\tname: "ColoredShape",\n  \t\t"extends": [\n  \t\t\t"bpmndi:BPMNShape"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "stroke",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "fill",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "ColoredEdge",\n  \t\t"extends": [\n  \t\t\t"bpmndi:BPMNEdge"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "stroke",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "fill",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t}\n  \t\t]\n  \t}\n  ];\n  var enumerations$2 = [\n  ];\n  var associations$4 = [\n  ];\n  var BiocPackage = {\n  \tname: name$4,\n  \turi: uri$4,\n  \tprefix: prefix$4,\n  \ttypes: types$4,\n  \tenumerations: enumerations$2,\n  \tassociations: associations$4\n  };\n\n  var name$5 = "BPMN in Color";\n  var uri$5 = "http://www.omg.org/spec/BPMN/non-normative/color/1.0";\n  var prefix$5 = "color";\n  var types$5 = [\n  \t{\n  \t\tname: "ColoredLabel",\n  \t\t"extends": [\n  \t\t\t"bpmndi:BPMNLabel"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "color",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "ColoredShape",\n  \t\t"extends": [\n  \t\t\t"bpmndi:BPMNShape"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "background-color",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t},\n  \t\t\t{\n  \t\t\t\tname: "border-color",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t}\n  \t\t]\n  \t},\n  \t{\n  \t\tname: "ColoredEdge",\n  \t\t"extends": [\n  \t\t\t"bpmndi:BPMNEdge"\n  \t\t],\n  \t\tproperties: [\n  \t\t\t{\n  \t\t\t\tname: "border-color",\n  \t\t\t\tisAttr: true,\n  \t\t\t\ttype: "String"\n  \t\t\t}\n  \t\t]\n  \t}\n  ];\n  var enumerations$3 = [\n  ];\n  var associations$5 = [\n  ];\n  var BpmnInColorPackage = {\n  \tname: name$5,\n  \turi: uri$5,\n  \tprefix: prefix$5,\n  \ttypes: types$5,\n  \tenumerations: enumerations$3,\n  \tassociations: associations$5\n  };\n\n  var packages = {\n    bpmn: BpmnPackage,\n    bpmndi: BpmnDiPackage,\n    dc: DcPackage,\n    di: DiPackage,\n    bioc: BiocPackage,\n    color: BpmnInColorPackage\n  };\n\n  function simple(additionalPackages, options) {\n    var pks = assign({}, packages, additionalPackages);\n\n    return new BpmnModdle(pks, options);\n  }\n\n  return simple;\n\n})));\n'},52111:t=>{t.exports="\"use strict\";\n/**\n * Store the kernel and interpreter instances.\n */\n// eslint-disable-next-line\n// @ts-ignore: breaks typedoc\nlet kernel;\n// eslint-disable-next-line\n// @ts-ignore: breaks typedoc\nlet interpreter;\n// eslint-disable-next-line\n// @ts-ignore: breaks typedoc\nlet pyodide;\n// eslint-disable-next-line\n// @ts-ignore: breaks typedoc\nlet stdout_stream;\n// eslint-disable-next-line\n// @ts-ignore: breaks typedoc\nlet stderr_stream;\n// eslint-disable-next-line\n// @ts-ignore: breaks typedoc\nlet resolveInputReply;\n/**\n * Load Pyodided and initialize the interpreter.\n */\nasync function loadPyodideAndPackages() {\n    // as of 0.17.0 indexURL must be provided\n    pyodide = await loadPyodide({ indexURL });\n    await pyodide.loadPackage(['micropip']);\n    await pyodide.loadPackage(['matplotlib']);\n    await pyodide.runPythonAsync(`\n    import micropip\n    await micropip.install([\n      'traitlets',\n      '${_widgetsnbextensionWheelUrl}',\n      '${_nbformatWheelUrl}',\n      '${_ipykernelWheelUrl}'\n    ])\n    await micropip.install([\n      '${_pyoliteWheelUrl}'\n    ]);\n    await micropip.install('ipython');\n    import pyolite\n    import json\n    import os\n    os.environ.update(json.loads('${_envJson}'))\n  `);\n    pyodide.registerJsModule('BpmnModdle', BpmnModdle);\n    // make copies of these so they don't get garbage collected\n    kernel = pyodide.globals.get('pyolite').kernel_instance.copy();\n    stdout_stream = pyodide.globals.get('pyolite').stdout_stream.copy();\n    stderr_stream = pyodide.globals.get('pyolite').stderr_stream.copy();\n    interpreter = kernel.interpreter.copy();\n    interpreter.send_comm = sendComm;\n    const version = pyodide.globals.get('pyolite').__version__;\n    console.log('Pyolite kernel initialized, version', version);\n}\n/**\n * Recursively convert a Map to a JavaScript object\n * @param The Map object to convert\n */\nfunction mapToObject(obj) {\n    const out = obj instanceof Array ? [] : {};\n    obj.forEach((value, key) => {\n        out[key] =\n            value instanceof Map || value instanceof Array ? mapToObject(value) : value;\n    });\n    return out;\n}\n/**\n * Format the response from the Pyodide evaluation.\n *\n * @param res The result object from the Pyodide evaluation\n */\nfunction formatResult(res) {\n    if (!pyodide.isPyProxy(res)) {\n        return res;\n    }\n    // TODO: this is a bit brittle\n    const m = res.toJs();\n    const results = mapToObject(m);\n    return results;\n}\n// eslint-disable-next-line\n// @ts-ignore: breaks typedoc\nconst pyodideReadyPromise = loadPyodideAndPackages();\n/**\n * Send a comm message to the front-end.\n *\n * @param type The type of the comm message.\n * @param content The content.\n * @param metadata The metadata.\n * @param ident The ident.\n * @param buffers The binary buffers.\n */\nasync function sendComm(type, content, metadata, ident, buffers) {\n    postMessage({\n        type: type,\n        content: formatResult(content),\n        metadata: formatResult(metadata),\n        ident: formatResult(ident),\n        buffers: formatResult(buffers),\n        parentHeader: formatResult(kernel._parent_header)['header']\n    });\n}\nasync function getpass(prompt) {\n    prompt = typeof prompt === 'undefined' ? '' : prompt;\n    await sendInputRequest(prompt, true);\n    const replyPromise = new Promise(resolve => {\n        resolveInputReply = resolve;\n    });\n    const result = await replyPromise;\n    return result['value'];\n}\nasync function input(prompt) {\n    prompt = typeof prompt === 'undefined' ? '' : prompt;\n    await sendInputRequest(prompt, false);\n    const replyPromise = new Promise(resolve => {\n        resolveInputReply = resolve;\n    });\n    const result = await replyPromise;\n    return result['value'];\n}\n/**\n * Send a input request to the front-end.\n *\n * @param prompt the text to show at the prompt\n * @param password Is the request for a password?\n */\nasync function sendInputRequest(prompt, password) {\n    const content = {\n        prompt,\n        password\n    };\n    postMessage({\n        type: 'input_request',\n        parentHeader: formatResult(kernel._parent_header)['header'],\n        content\n    });\n}\n/**\n * Execute code with the interpreter.\n *\n * @param content The incoming message with the code to execute.\n */\nasync function execute(content) {\n    const publishExecutionResult = (prompt_count, data, metadata) => {\n        const bundle = {\n            execution_count: prompt_count,\n            data: formatResult(data),\n            metadata: formatResult(metadata)\n        };\n        postMessage({\n            parentHeader: formatResult(kernel._parent_header)['header'],\n            bundle,\n            type: 'execute_result'\n        });\n    };\n    const publishExecutionError = (ename, evalue, traceback) => {\n        const bundle = {\n            ename: ename,\n            evalue: evalue,\n            traceback: traceback\n        };\n        postMessage({\n            parentHeader: formatResult(kernel._parent_header)['header'],\n            bundle,\n            type: 'execute_error'\n        });\n    };\n    const clearOutputCallback = (wait) => {\n        const bundle = {\n            wait: formatResult(wait)\n        };\n        postMessage({\n            parentHeader: formatResult(kernel._parent_header)['header'],\n            bundle,\n            type: 'clear_output'\n        });\n    };\n    const displayDataCallback = (data, metadata, transient) => {\n        const bundle = {\n            data: formatResult(data),\n            metadata: formatResult(metadata),\n            transient: formatResult(transient)\n        };\n        postMessage({\n            parentHeader: formatResult(kernel._parent_header)['header'],\n            bundle,\n            type: 'display_data'\n        });\n    };\n    const updateDisplayDataCallback = (data, metadata, transient) => {\n        const bundle = {\n            data: formatResult(data),\n            metadata: formatResult(metadata),\n            transient: formatResult(transient)\n        };\n        postMessage({\n            parentHeader: formatResult(kernel._parent_header)['header'],\n            bundle,\n            type: 'update_display_data'\n        });\n    };\n    const publishStreamCallback = (name, text) => {\n        const bundle = {\n            name: formatResult(name),\n            text: formatResult(text)\n        };\n        postMessage({\n            parentHeader: formatResult(kernel._parent_header)['header'],\n            bundle,\n            type: 'stream'\n        });\n    };\n    stdout_stream.publish_stream_callback = publishStreamCallback;\n    stderr_stream.publish_stream_callback = publishStreamCallback;\n    interpreter.display_pub.clear_output_callback = clearOutputCallback;\n    interpreter.display_pub.display_data_callback = displayDataCallback;\n    interpreter.display_pub.update_display_data_callback = updateDisplayDataCallback;\n    interpreter.displayhook.publish_execution_result = publishExecutionResult;\n    interpreter.input = input;\n    interpreter.getpass = getpass;\n    const res = await kernel.run(content.code);\n    const results = formatResult(res);\n    if (results['status'] === 'error') {\n        publishExecutionError(results['ename'], results['evalue'], results['traceback']);\n    }\n    return results;\n}\n/**\n * Complete the code submitted by a user.\n *\n * @param content The incoming message with the code to complete.\n */\nfunction complete(content) {\n    const res = kernel.complete(content.code, content.cursor_pos);\n    const results = formatResult(res);\n    return results;\n}\n/**\n * Inspect the code submitted by a user.\n *\n * @param content The incoming message with the code to inspect.\n */\nfunction inspect(content) {\n    const res = kernel.inspect(content.code, content.cursor_pos, content.detail_level);\n    const results = formatResult(res);\n    return results;\n}\n/**\n * Check code for completeness submitted by a user.\n *\n * @param content The incoming message with the code to check.\n */\nfunction isComplete(content) {\n    const res = kernel.is_complete(content.code);\n    const results = formatResult(res);\n    return results;\n}\n/**\n * Respond to the commInfoRequest.\n *\n * @param content The incoming message with the comm target name.\n */\nfunction commInfo(content) {\n    const res = kernel.comm_info(content.target_name);\n    const results = formatResult(res);\n    return {\n        comms: results,\n        status: 'ok'\n    };\n}\n/**\n * Respond to the commOpen.\n *\n * @param content The incoming message with the comm open.\n */\nfunction commOpen(content) {\n    const res = kernel.comm_manager.comm_open(pyodide.toPy(content));\n    const results = formatResult(res);\n    return results;\n}\n/**\n * Respond to the commMsg.\n *\n * @param content The incoming message with the comm msg.\n */\nfunction commMsg(content) {\n    const res = kernel.comm_manager.comm_msg(pyodide.toPy(content));\n    const results = formatResult(res);\n    return results;\n}\n/**\n * Respond to the commClose.\n *\n * @param content The incoming message with the comm close.\n */\nfunction commClose(content) {\n    const res = kernel.comm_manager.comm_close(pyodide.toPy(content));\n    const results = formatResult(res);\n    return results;\n}\n/**\n * Process a message sent to the worker.\n *\n * @param event The message event to process\n */\nself.onmessage = async (event) => {\n    await pyodideReadyPromise;\n    const data = event.data;\n    let results;\n    const messageType = data.type;\n    const messageContent = data.data;\n    kernel._parent_header = pyodide.toPy(data.parent);\n    switch (messageType) {\n        case 'execute-request':\n            console.log('Perform execution inside worker', data);\n            results = await execute(messageContent);\n            break;\n        case 'input-reply':\n            resolveInputReply(messageContent);\n            return;\n        case 'inspect-request':\n            results = inspect(messageContent);\n            break;\n        case 'is-complete-request':\n            results = isComplete(messageContent);\n            break;\n        case 'complete-request':\n            results = complete(messageContent);\n            break;\n        case 'comm-info-request':\n            results = commInfo(messageContent);\n            break;\n        case 'comm-open':\n            results = commOpen(messageContent);\n            break;\n        case 'comm-msg':\n            results = commMsg(messageContent);\n            break;\n        case 'comm-close':\n            results = commClose(messageContent);\n            break;\n        default:\n            break;\n    }\n    const reply = {\n        parentHeader: data.parent['header'],\n        type: 'reply',\n        results\n    };\n    postMessage(reply);\n};\n"}}]);
//# sourceMappingURL=1753.75eb1866e2e21e24e8a5.js.map